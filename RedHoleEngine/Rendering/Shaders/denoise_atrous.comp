#version 450

/*
 * A-Trous Wavelet Denoiser
 * 
 * Edge-preserving denoiser using a-trous wavelet transform.
 * Performs multi-scale filtering by increasing the step size exponentially
 * across multiple passes. Uses G-buffer data (normals, depth) for edge detection.
 * 
 * Reference: "Edge-Avoiding A-Trous Wavelet Transform for fast Global Illumination Filtering"
 *            Dammertz et al., HPG 2010
 */

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Input/output images
layout(set = 0, binding = 0, rgba32f) uniform image2D inputImage;
layout(set = 0, binding = 1, rgba32f) uniform image2D outputImage;
layout(set = 0, binding = 2, rgba32f) uniform readonly image2D normalImage;  // World-space normals
layout(set = 0, binding = 3, r32f) uniform readonly image2D depthImage;       // Linear depth

// Uniforms
layout(set = 0, binding = 4) uniform DenoiseParams {
    ivec2 resolution;
    int stepSize;           // 1, 2, 4, 8, 16, 32 for each iteration
    float colorSigma;       // Color weight sensitivity (phi_c)
    float normalSigma;      // Normal weight sensitivity (phi_n)
    float depthSigma;       // Depth weight sensitivity (phi_p)
    float pad0;
    float pad1;
} params;

// 5x5 B3-spline wavelet kernel weights (separable, but we use 2D for simplicity)
const float kernel[5] = float[5](1.0/16.0, 4.0/16.0, 6.0/16.0, 4.0/16.0, 1.0/16.0);

// Offset pattern for 5x5 kernel
const ivec2 offsets[25] = ivec2[25](
    ivec2(-2, -2), ivec2(-1, -2), ivec2(0, -2), ivec2(1, -2), ivec2(2, -2),
    ivec2(-2, -1), ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1), ivec2(2, -1),
    ivec2(-2,  0), ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0), ivec2(2,  0),
    ivec2(-2,  1), ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1), ivec2(2,  1),
    ivec2(-2,  2), ivec2(-1,  2), ivec2(0,  2), ivec2(1,  2), ivec2(2,  2)
);

// Kernel weights (product of 1D kernel)
const float kernelWeights[25] = float[25](
    1.0/256.0,  4.0/256.0,  6.0/256.0,  4.0/256.0, 1.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    6.0/256.0, 24.0/256.0, 36.0/256.0, 24.0/256.0, 6.0/256.0,
    4.0/256.0, 16.0/256.0, 24.0/256.0, 16.0/256.0, 4.0/256.0,
    1.0/256.0,  4.0/256.0,  6.0/256.0,  4.0/256.0, 1.0/256.0
);

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    
    if (pixelCoord.x >= params.resolution.x || pixelCoord.y >= params.resolution.y) {
        return;
    }
    
    // Load center pixel data
    vec4 centerColor = imageLoad(inputImage, pixelCoord);
    vec3 centerNormal = imageLoad(normalImage, pixelCoord).xyz;
    float centerDepth = imageLoad(depthImage, pixelCoord).r;
    
    // Handle invalid pixels (sky, etc.)
    if (centerDepth <= 0.0 || length(centerNormal) < 0.5) {
        imageStore(outputImage, pixelCoord, centerColor);
        return;
    }
    
    // Normalize the center normal
    centerNormal = normalize(centerNormal);
    
    vec3 colorSum = vec3(0.0);
    float weightSum = 0.0;
    
    // Apply 5x5 a-trous filter with edge-stopping weights
    for (int i = 0; i < 25; i++) {
        ivec2 sampleCoord = pixelCoord + offsets[i] * params.stepSize;
        
        // Boundary check
        if (sampleCoord.x < 0 || sampleCoord.x >= params.resolution.x ||
            sampleCoord.y < 0 || sampleCoord.y >= params.resolution.y) {
            continue;
        }
        
        // Load sample data
        vec3 sampleColor = imageLoad(inputImage, sampleCoord).rgb;
        vec3 sampleNormal = imageLoad(normalImage, sampleCoord).xyz;
        float sampleDepth = imageLoad(depthImage, sampleCoord).r;
        
        // Skip invalid samples
        if (sampleDepth <= 0.0 || length(sampleNormal) < 0.5) {
            continue;
        }
        
        sampleNormal = normalize(sampleNormal);
        
        // Calculate edge-stopping weights
        
        // Color weight - based on luminance difference
        vec3 colorDiff = centerColor.rgb - sampleColor;
        float colorDist2 = dot(colorDiff, colorDiff);
        float colorWeight = exp(-colorDist2 / (params.colorSigma * params.colorSigma + 0.0001));
        
        // Normal weight - based on angular difference
        float normalDot = max(0.0, dot(centerNormal, sampleNormal));
        float normalWeight = pow(normalDot, params.normalSigma * 128.0);
        
        // Depth weight - based on depth plane distance
        // Project depth difference onto the normal direction for better edge detection
        float depthDiff = abs(centerDepth - sampleDepth);
        float depthGradient = centerDepth * 0.01; // Scale factor based on depth
        float depthWeight = exp(-depthDiff / (params.depthSigma * depthGradient + 0.0001));
        
        // Combined weight
        float weight = kernelWeights[i] * colorWeight * normalWeight * depthWeight;
        
        colorSum += sampleColor * weight;
        weightSum += weight;
    }
    
    // Normalize and output
    vec3 denoisedColor = (weightSum > 0.0001) ? colorSum / weightSum : centerColor.rgb;
    
    // Preserve alpha
    imageStore(outputImage, pixelCoord, vec4(denoisedColor, centerColor.a));
}
