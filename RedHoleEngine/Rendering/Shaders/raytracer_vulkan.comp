#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(set = 0, binding = 0, rgba32f) uniform image2D outputImage;
layout(set = 0, binding = 4, rgba32f) uniform image2D accumImage;

layout(set = 0, binding = 1) uniform UniformBlock {
    vec2 u_Resolution;
    float u_Time;
    float _pad1;
    vec3 u_CameraPos;
    float _pad2;
    vec3 u_CameraForward;
    float _pad3;
    vec3 u_CameraRight;
    float _pad4;
    vec3 u_CameraUp;
    float u_Fov;
    vec3 u_BlackHolePos;
    float u_BlackHoleMass;
    float u_SchwarzschildRadius;
    float u_DiskInnerRadius;
    float u_DiskOuterRadius;
    vec4 u_RaySettings;
    vec4 u_FrameSettings;
    vec4 u_LensingSettings;  // x=maxSteps, y=stepSize, z=bvhCheckInterval, w=maxDistance
    // Kerr black hole parameters (rotating black holes)
    float u_BlackHoleSpin;       // Dimensionless spin parameter a* (0 to 0.998)
    float u_KerrParameter;       // a = a* * M (spin in geometric units)
    float u_OuterHorizonRadius;  // r+ = M + sqrt(M^2 - a^2)
    float u_ErgosphereRadius;    // Equatorial ergosphere radius
    vec3 u_BlackHoleSpinAxis;    // Spin axis direction (normalized)
    float u_ShowErgosphere;      // 1.0 = show, 0.0 = hide
    // Visualization settings
    float u_ErgosphereOpacity;   // 0.0 - 1.0
    float u_DiskISCO;            // Innermost Stable Circular Orbit radius
    float u_DiskThickness;       // Disk half-thickness at outer edge
    float u_ShowPhotonSphere;    // 1.0 = show, 0.0 = hide
    float u_PhotonSphereOpacity; // 0.0 - 1.0
    float u_PhotonSphereRadius;  // Radius where light can orbit
    float _pad9;
    float _pad10;
};

struct BvhNode {
    vec3 boundsMin;
    int leftFirst;
    vec3 boundsMax;
    int triCount;
};

// Triangle data with UV coordinates for texture mapping
// Layout matches RaytracerTriangle C# struct (144 bytes)
// IMPORTANT: std430 requires vec4 to be 16-byte aligned
struct GpuTriangle {
    // Vertex positions (48 bytes, offset 0)
    vec3 v0;              // offset 0
    int materialIndex;    // offset 12
    vec3 v1;              // offset 16
    int pad1;             // offset 28
    vec3 v2;              // offset 32
    int pad2;             // offset 44
    
    // Normal (16 bytes, offset 48)
    vec3 normal;          // offset 48
    int pad3;             // offset 60
    
    // UV coordinates for each vertex (24 bytes, offset 64)
    vec2 uv0;             // offset 64
    vec2 uv1;             // offset 72
    vec2 uv2;             // offset 80
    
    // Padding to align tangent (vec4) to 16-byte boundary (offset 88)
    float padUV0;         // offset 88
    float padUV1;         // offset 92
    
    // Tangent for normal mapping (16 bytes, offset 96)
    vec4 tangent;         // xyz = tangent direction, w = handedness
    
    // Colors for backward compatibility (32 bytes, offset 112)
    vec4 albedo;          // offset 112
    vec4 emissive;        // offset 128
    
    // Total: 144 bytes
};

layout(std430, set = 0, binding = 2) buffer BvhNodes {
    BvhNode bvhNodes[];
};

layout(std430, set = 0, binding = 3) buffer Triangles {
    GpuTriangle triangles[];
};

// GPU Material buffer - matches GpuMaterial struct in C# (80 bytes per material)
// Layout: baseColorFactor(16), metallic(4), roughness(4), normalScale(4), occlusionStrength(4),
//         emissiveFactor(12), emissiveIntensity(4), ior(4), specularFactor(4), clearcoat(4), clearcoatRoughness(4),
//         textureIndices(16): baseColor, metallicRoughness, normal, emissive
struct GpuMaterial {
    vec4 baseColorFactor;      // 16 bytes (offset 0)
    float metallic;            // 4 bytes (offset 16)
    float roughness;           // 4 bytes (offset 20)
    float normalScale;         // 4 bytes (offset 24)
    float occlusionStrength;   // 4 bytes (offset 28)
    vec3 emissiveFactor;       // 12 bytes (offset 32)
    float emissiveIntensity;   // 4 bytes (offset 44)
    float ior;                 // 4 bytes (offset 48)
    float specularFactor;      // 4 bytes (offset 52)
    float clearcoat;           // 4 bytes (offset 56)
    float clearcoatRoughness;  // 4 bytes (offset 60)
    // Texture indices (-1 = no texture)
    int baseColorTextureIndex;          // 4 bytes (offset 64)
    int metallicRoughnessTextureIndex;  // 4 bytes (offset 68)
    int normalTextureIndex;             // 4 bytes (offset 72)
    int emissiveTextureIndex;           // 4 bytes (offset 76)
};

layout(std430, set = 0, binding = 5) buffer Materials {
    GpuMaterial materials[];
};

// Texture array for PBR materials (binding 6)
// All textures are stored in a single array, indexed by material texture indices
layout(set = 0, binding = 6) uniform sampler2D materialTextures[32]; // Support up to 32 textures

// Environment map for IBL (binding 7) - equirectangular HDR
layout(set = 0, binding = 7) uniform sampler2D envMap;

// Constants (must be defined before functions that use them)
const float PI = 3.14159265359;
const float INV_PI = 0.31830988618;
const float EPSILON = 0.0001;

// Sample a texture from the array (returns vec4(1) if index is invalid)
vec4 sampleMaterialTexture(int textureIndex, vec2 uv) {
    if (textureIndex < 0 || textureIndex >= 32) {
        return vec4(1.0);
    }
    return texture(materialTextures[textureIndex], uv);
}

// Sample environment map using direction (equirectangular mapping)
vec3 sampleEnvironment(vec3 dir) {
    // Handle zero/degenerate directions
    float len = length(dir);
    if (len < EPSILON) {
        return vec3(0.0);
    }
    dir = dir / len;
    
    float u = atan(dir.z, dir.x) / (2.0 * PI) + 0.5;
    float v = asin(clamp(dir.y, -1.0, 1.0)) / PI + 0.5;
    
    // Clamp UVs to valid range
    u = clamp(u, 0.0, 1.0);
    v = clamp(v, 0.0, 1.0);
    
    vec3 color = texture(envMap, vec2(u, v)).rgb;
    
    // Protect against NaN from texture sampling
    if (any(isnan(color)) || any(isinf(color))) {
        return vec3(0.0);
    }
    return color;
}

// Sample environment with roughness-based blur (approximation)
// For proper IBL, we would prefilter the environment map
vec3 sampleEnvironmentRough(vec3 dir, float roughness) {
    // Simple mip-like blur approximation by sampling multiple directions
    if (roughness < 0.1) {
        return sampleEnvironment(dir);
    }
    
    // Create tangent space for the reflection direction
    vec3 N = normalize(dir);
    vec3 up = abs(N.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);
    vec3 T = normalize(cross(up, N));
    vec3 B = cross(N, T);
    
    // Sample in a cone around the reflection direction
    vec3 result = vec3(0.0);
    float coneAngle = roughness * 0.5; // Cone half-angle based on roughness
    
    const int NUM_SAMPLES = 4;
    float weights = 0.0;
    
    for (int i = 0; i < NUM_SAMPLES; i++) {
        // Distribute samples in a pattern
        float angle = float(i) / float(NUM_SAMPLES) * 2.0 * PI;
        float r = coneAngle * (0.5 + 0.5 * float(i % 2)); // Vary radius
        
        vec3 offset = T * cos(angle) * r + B * sin(angle) * r;
        vec3 sampleDir = normalize(N + offset);
        
        float w = 1.0 - length(offset);
        result += sampleEnvironment(sampleDir) * w;
        weights += w;
    }
    
    result /= weights;
    
    // Blend with center sample
    return mix(sampleEnvironment(dir), result, roughness);
}

// ============================================
// PBR Material Structure
// ============================================

struct PbrMaterial {
    vec4 baseColorFactor;      // RGBA base color
    float metallic;            // 0 = dielectric, 1 = metal
    float roughness;           // 0 = smooth, 1 = rough
    float normalScale;         // Normal map intensity
    float occlusionStrength;   // AO intensity
    vec3 emissiveFactor;       // Emissive color
    float emissiveIntensity;   // Emissive multiplier
    float ior;                 // Index of refraction
    float specularFactor;      // Specular intensity
    float clearcoat;           // Clearcoat intensity
    float clearcoatRoughness;  // Clearcoat roughness
};

// Default PBR material
PbrMaterial defaultMaterial() {
    PbrMaterial mat;
    mat.baseColorFactor = vec4(1.0);
    mat.metallic = 0.0;
    mat.roughness = 0.5;
    mat.normalScale = 1.0;
    mat.occlusionStrength = 1.0;
    mat.emissiveFactor = vec3(0.0);
    mat.emissiveIntensity = 1.0;
    mat.ior = 1.5;
    mat.specularFactor = 1.0;
    mat.clearcoat = 0.0;
    mat.clearcoatRoughness = 0.0;
    return mat;
}

// Generate procedural UV from world position (triplanar-style)
vec2 generateProceduralUV(vec3 worldPos, vec3 normal) {
    // Use dominant axis for UV projection
    vec3 absNormal = abs(normal);
    vec2 uv;
    if (absNormal.x > absNormal.y && absNormal.x > absNormal.z) {
        uv = worldPos.yz;
    } else if (absNormal.y > absNormal.z) {
        uv = worldPos.xz;
    } else {
        uv = worldPos.xy;
    }
    return fract(uv); // Tile the UV
}

// Get material for a triangle, using the material buffer if available
// worldPos is used for procedural UV generation when textures are present
PbrMaterial getMaterialWithTextures(GpuTriangle tri, vec3 worldPos, vec3 normal) {
    PbrMaterial mat = defaultMaterial();
    
    // Check if triangle has a valid material index
    int matIdx = tri.materialIndex;
    if (matIdx >= 0 && matIdx < materials.length()) {
        // Use the GPU material buffer
        GpuMaterial gpuMat = materials[matIdx];
        mat.baseColorFactor = gpuMat.baseColorFactor;
        mat.metallic = gpuMat.metallic;
        mat.roughness = gpuMat.roughness;
        mat.normalScale = gpuMat.normalScale;
        mat.occlusionStrength = gpuMat.occlusionStrength;
        mat.emissiveFactor = gpuMat.emissiveFactor;
        mat.emissiveIntensity = gpuMat.emissiveIntensity;
        mat.ior = gpuMat.ior;
        mat.specularFactor = gpuMat.specularFactor;
        mat.clearcoat = gpuMat.clearcoat;
        mat.clearcoatRoughness = gpuMat.clearcoatRoughness;
        
        // Sample textures if available (using procedural UVs)
        vec2 uv = generateProceduralUV(worldPos, normal);
        
        // Base color texture
        if (gpuMat.baseColorTextureIndex >= 0) {
            vec4 texColor = sampleMaterialTexture(gpuMat.baseColorTextureIndex, uv);
            mat.baseColorFactor *= texColor; // Multiply factor with texture
        }
        
        // Metallic-Roughness texture (G=roughness, B=metallic)
        if (gpuMat.metallicRoughnessTextureIndex >= 0) {
            vec4 mrTex = sampleMaterialTexture(gpuMat.metallicRoughnessTextureIndex, uv);
            mat.roughness *= mrTex.g;
            mat.metallic *= mrTex.b;
        }
        
        // Emissive texture
        if (gpuMat.emissiveTextureIndex >= 0) {
            vec4 emTex = sampleMaterialTexture(gpuMat.emissiveTextureIndex, uv);
            mat.emissiveFactor *= emTex.rgb;
        }
        
        // Note: Normal mapping requires tangent space calculation, 
        // which needs proper UVs - skipped for procedural UVs
        
    } else {
        // Fallback: derive material from triangle's embedded color data
        mat.baseColorFactor = tri.albedo;
        mat.emissiveFactor = tri.emissive.rgb;
        mat.emissiveIntensity = max(tri.emissive.a, 1.0);
        // Estimate roughness from color brightness
        float brightness = dot(tri.albedo.rgb, vec3(0.299, 0.587, 0.114));
        mat.roughness = 0.3 + 0.4 * (1.0 - brightness);
    }
    
    return mat;
}

// Get material without texture sampling (backward compatibility)
PbrMaterial getMaterial(GpuTriangle tri) {
    return getMaterialWithTextures(tri, vec3(0.0), vec3(0.0, 1.0, 0.0));
}

// Legacy alias for compatibility
PbrMaterial materialFromTriangle(GpuTriangle tri) {
    return getMaterial(tri);
}

// ============================================
// PBR BRDF Functions (GGX/Smith/Schlick)
// ============================================

// Fresnel-Schlick approximation
// F0 = reflectance at normal incidence
vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

// Fresnel-Schlick with roughness (for IBL)
vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

// GGX/Trowbridge-Reitz Normal Distribution Function
float distributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    
    float denom = NdotH2 * (a2 - 1.0) + 1.0;
    denom = PI * denom * denom;
    
    return a2 / max(denom, EPSILON);
}

// Smith's Schlick-GGX Geometry function (single direction)
float geometrySchlickGGX(float NdotV, float roughness) {
    float r = roughness + 1.0;
    float k = (r * r) / 8.0;
    
    return NdotV / (NdotV * (1.0 - k) + k);
}

// Smith's Geometry function (combines view and light directions)
float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = geometrySchlickGGX(NdotV, roughness);
    float ggx1 = geometrySchlickGGX(NdotL, roughness);
    
    return ggx1 * ggx2;
}

// Calculate F0 (base reflectivity) for dielectric materials from IOR
vec3 calculateF0(vec3 albedo, float metallic, float ior) {
    // Dielectric F0 from IOR: F0 = ((n1 - n2) / (n1 + n2))^2
    float f0Dielectric = pow((1.0 - ior) / (1.0 + ior), 2.0);
    vec3 F0 = vec3(f0Dielectric);
    
    // For metals, F0 is the albedo color
    // For dielectrics, F0 is grayscale based on IOR
    return mix(F0, albedo, metallic);
}

// Cook-Torrance BRDF evaluation
// Returns the outgoing radiance for a given light direction
vec3 evaluateBRDF(
    vec3 albedo,
    float metallic,
    float roughness,
    float ior,
    vec3 N,       // Surface normal
    vec3 V,       // View direction (toward camera)
    vec3 L,       // Light direction (toward light)
    vec3 radiance // Incoming light radiance
) {
    vec3 H = normalize(V + L);
    
    float NdotL = max(dot(N, L), 0.0);
    float NdotV = max(dot(N, V), 0.0);
    float HdotV = max(dot(H, V), 0.0);
    
    if (NdotL <= 0.0) return vec3(0.0);
    
    // Calculate F0
    vec3 F0 = calculateF0(albedo, metallic, ior);
    
    // Cook-Torrance BRDF
    float D = distributionGGX(N, H, roughness);
    float G = geometrySmith(N, V, L, roughness);
    vec3 F = fresnelSchlick(HdotV, F0);
    
    // Specular term
    vec3 numerator = D * G * F;
    float denominator = 4.0 * NdotV * NdotL + EPSILON;
    vec3 specular = numerator / denominator;
    
    // Diffuse term (energy conservation)
    // kS is the specular contribution (Fresnel)
    // kD is the diffuse contribution
    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    
    // Metals have no diffuse reflection
    kD *= 1.0 - metallic;
    
    // Lambertian diffuse
    vec3 diffuse = kD * albedo * INV_PI;
    
    return (diffuse + specular) * radiance * NdotL;
}

// Importance sample GGX distribution for indirect lighting
// Returns a microfacet normal based on roughness
vec3 importanceSampleGGX(vec2 Xi, vec3 N, float roughness) {
    float a = roughness * roughness;
    
    float phi = 2.0 * PI * Xi.x;
    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
    // Spherical to Cartesian
    vec3 H;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;
    
    // Tangent space to world space
    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);
    
    return normalize(tangent * H.x + bitangent * H.y + N * H.z);
}

// Sample direction for next bounce based on material properties
vec3 sampleBRDF(
    vec3 N,
    vec3 V,
    float roughness,
    float metallic,
    vec2 random,
    out float pdf
) {
    // For highly rough surfaces or dielectrics, use cosine-weighted hemisphere
    // For smooth metals, use GGX importance sampling
    
    float specularWeight = mix(0.04, 1.0, metallic) * (1.0 - roughness);
    
    if (random.x < specularWeight) {
        // Specular bounce - importance sample GGX
        vec3 H = importanceSampleGGX(random, N, roughness);
        vec3 L = reflect(-V, H);
        
        float NdotH = max(dot(N, H), 0.0);
        float HdotV = max(dot(H, V), 0.0);
        float D = distributionGGX(N, H, roughness);
        
        pdf = D * NdotH / (4.0 * HdotV + EPSILON);
        return L;
    } else {
        // Diffuse bounce - cosine-weighted hemisphere
        float r1 = random.x / (1.0 - specularWeight);
        float r2 = random.y;
        
        float sinTheta = sqrt(r1);
        float cosTheta = sqrt(1.0 - r1);
        float phi = 2.0 * PI * r2;
        
        vec3 H;
        H.x = sinTheta * cos(phi);
        H.y = sinTheta * sin(phi);
        H.z = cosTheta;
        
        vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
        vec3 tangent = normalize(cross(up, N));
        vec3 bitangent = cross(N, tangent);
        
        vec3 L = normalize(tangent * H.x + bitangent * H.y + N * H.z);
        
        pdf = max(dot(N, L), 0.0) * INV_PI;
        return L;
    }
}

// Clearcoat BRDF layer (simplified GGX for top coat)
vec3 evaluateClearcoat(
    float clearcoat,
    float clearcoatRoughness,
    vec3 N,
    vec3 V,
    vec3 L
) {
    if (clearcoat <= 0.0) return vec3(0.0);
    
    vec3 H = normalize(V + L);
    float NdotL = max(dot(N, L), 0.0);
    float NdotV = max(dot(N, V), 0.0);
    float HdotV = max(dot(H, V), 0.0);
    
    // Clearcoat is always dielectric with IOR ~1.5 (F0 = 0.04)
    vec3 F = fresnelSchlick(HdotV, vec3(0.04));
    float D = distributionGGX(N, H, clearcoatRoughness);
    float G = geometrySmith(N, V, L, clearcoatRoughness);
    
    vec3 specular = (D * G * F) / (4.0 * NdotV * NdotL + EPSILON);
    
    return specular * clearcoat * NdotL;
}

// ============================================
// PBR Shading with Simple Environment Light
// ============================================

// IBL ambient/environment lighting using environment map
vec3 getSkyColor(vec3 direction) {
    // Sample environment map for IBL
    vec3 envColor = sampleEnvironment(direction);
    
    // Check if we have a valid environment (not pure black)
    float brightness = dot(envColor, vec3(0.299, 0.587, 0.114));
    
    if (brightness > 0.001) {
        // Scale down for ambient to avoid over-brightness
        return envColor * 0.3;
    }
    
    // Fallback to procedural sky gradient
    float t = direction.y * 0.5 + 0.5;
    vec3 horizonColor = vec3(0.5, 0.7, 1.0) * 0.3;
    vec3 zenithColor = vec3(0.1, 0.2, 0.5) * 0.5;
    vec3 groundColor = vec3(0.1, 0.08, 0.06) * 0.2;
    
    if (direction.y < 0.0) {
        return mix(horizonColor, groundColor, -direction.y);
    }
    return mix(horizonColor, zenithColor, direction.y);
}

// IBL specular - sample environment with roughness-based blur
vec3 getSpecularIBL(vec3 R, float roughness) {
    return sampleEnvironmentRough(R, roughness) * 0.5;
}

// Shade a surface hit using PBR
vec3 shadePBR(
    vec3 hitPos,
    vec3 normal,
    vec3 viewDir,  // Direction toward camera
    GpuTriangle tri
) {
    // Create PBR material from triangle data
    PbrMaterial mat = materialFromTriangle(tri);
    
    vec3 N = normalize(normal);
    vec3 V = normalize(viewDir);
    
    vec3 albedo = mat.baseColorFactor.rgb;
    float metallic = mat.metallic;
    float roughness = max(mat.roughness, 0.04); // Avoid zero roughness
    
    vec3 result = vec3(0.0);
    
    // === Direct Lighting from Key Light ===
    // Simple directional light from above-right
    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
    vec3 lightColor = vec3(1.0, 0.98, 0.95) * 2.0;
    
    result += evaluateBRDF(albedo, metallic, roughness, mat.ior, N, V, lightDir, lightColor);
    
    // === Fill Light ===
    vec3 fillDir = normalize(vec3(-0.7, 0.3, -0.5));
    vec3 fillColor = vec3(0.3, 0.4, 0.6) * 0.5;
    result += evaluateBRDF(albedo, metallic, roughness, mat.ior, N, V, fillDir, fillColor);
    
    // === Rim/Back Light ===
    vec3 rimDir = normalize(vec3(0.0, 0.2, -1.0));
    vec3 rimColor = vec3(0.8, 0.7, 0.6) * 0.3;
    result += evaluateBRDF(albedo, metallic, roughness, mat.ior, N, V, rimDir, rimColor);
    
    // === Ambient/Environment ===
    // Approximate image-based lighting with sky color
    vec3 F0 = calculateF0(albedo, metallic, mat.ior);
    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);
    
    vec3 kS = F;
    vec3 kD = (1.0 - kS) * (1.0 - metallic);
    
    // Diffuse ambient from hemisphere
    vec3 ambientDiffuse = getSkyColor(N) * albedo * kD;
    
    // Specular ambient from reflection direction
    vec3 R = reflect(-V, N);
    vec3 ambientSpecular = getSkyColor(R) * F;
    
    // Roughness reduces specular contribution
    ambientSpecular *= 1.0 - roughness * 0.9;
    
    float ao = mat.occlusionStrength;
    result += (ambientDiffuse + ambientSpecular) * ao;
    
    // === Clearcoat ===
    if (mat.clearcoat > 0.0) {
        result += evaluateClearcoat(mat.clearcoat, mat.clearcoatRoughness, N, V, lightDir) * lightColor;
    }
    
    // === Emissive ===
    result += mat.emissiveFactor * mat.emissiveIntensity;
    
    return result;
}

// Shade a surface hit using PBR with proper UV coordinates
vec3 shadePBRWithUV(
    vec3 hitPos,
    vec3 normal,
    vec3 viewDir,  // Direction toward camera
    GpuTriangle tri,
    vec2 uv        // Interpolated UV coordinates
) {
    PbrMaterial mat = defaultMaterial();
    
    // Check if triangle has a valid material index
    int matIdx = tri.materialIndex;
    if (matIdx >= 0 && matIdx < materials.length()) {
        GpuMaterial gpuMat = materials[matIdx];
        mat.baseColorFactor = gpuMat.baseColorFactor;
        mat.metallic = gpuMat.metallic;
        mat.roughness = gpuMat.roughness;
        mat.normalScale = gpuMat.normalScale;
        mat.occlusionStrength = gpuMat.occlusionStrength;
        mat.emissiveFactor = gpuMat.emissiveFactor;
        mat.emissiveIntensity = gpuMat.emissiveIntensity;
        mat.ior = gpuMat.ior;
        mat.specularFactor = gpuMat.specularFactor;
        mat.clearcoat = gpuMat.clearcoat;
        mat.clearcoatRoughness = gpuMat.clearcoatRoughness;
        
        // Sample textures using interpolated UVs
        if (gpuMat.baseColorTextureIndex >= 0) {
            vec4 texColor = sampleMaterialTexture(gpuMat.baseColorTextureIndex, uv);
            mat.baseColorFactor *= texColor;
        }
        
        if (gpuMat.metallicRoughnessTextureIndex >= 0) {
            vec4 mrTex = sampleMaterialTexture(gpuMat.metallicRoughnessTextureIndex, uv);
            mat.roughness *= mrTex.g;
            mat.metallic *= mrTex.b;
        }
        
        if (gpuMat.emissiveTextureIndex >= 0) {
            vec4 emTex = sampleMaterialTexture(gpuMat.emissiveTextureIndex, uv);
            mat.emissiveFactor *= emTex.rgb;
        }
        
        // Normal mapping (when tangent is available)
        if (gpuMat.normalTextureIndex >= 0 && length(tri.tangent.xyz) > 0.1) {
            vec3 normalTex = sampleMaterialTexture(gpuMat.normalTextureIndex, uv).rgb;
            normalTex = normalTex * 2.0 - 1.0; // Convert from [0,1] to [-1,1]
            normalTex.xy *= mat.normalScale;
            
            // Build TBN matrix
            vec3 T = normalize(tri.tangent.xyz);
            vec3 N = normalize(normal);
            vec3 B = cross(N, T) * tri.tangent.w; // Handedness
            mat3 TBN = mat3(T, B, N);
            
            normal = normalize(TBN * normalTex);
        }
    } else {
        // Fallback: use triangle's embedded color data
        mat.baseColorFactor = tri.albedo;
        mat.emissiveFactor = tri.emissive.rgb;
        mat.emissiveIntensity = max(tri.emissive.a, 1.0);
        float brightness = dot(tri.albedo.rgb, vec3(0.299, 0.587, 0.114));
        mat.roughness = 0.3 + 0.4 * (1.0 - brightness);
    }
    
    vec3 N = normalize(normal);
    vec3 V = normalize(viewDir);
    
    vec3 albedo = mat.baseColorFactor.rgb;
    float metallic = mat.metallic;
    float roughness = max(mat.roughness, 0.04);
    
    vec3 result = vec3(0.0);
    
    // === Direct Lighting ===
    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
    vec3 lightColor = vec3(1.0, 0.98, 0.95) * 2.0;
    result += evaluateBRDF(albedo, metallic, roughness, mat.ior, N, V, lightDir, lightColor);
    
    vec3 fillDir = normalize(vec3(-0.7, 0.3, -0.5));
    vec3 fillColor = vec3(0.3, 0.4, 0.6) * 0.5;
    result += evaluateBRDF(albedo, metallic, roughness, mat.ior, N, V, fillDir, fillColor);
    
    vec3 rimDir = normalize(vec3(0.0, 0.2, -1.0));
    vec3 rimColor = vec3(0.8, 0.7, 0.6) * 0.3;
    result += evaluateBRDF(albedo, metallic, roughness, mat.ior, N, V, rimDir, rimColor);
    
    // === IBL Ambient/Environment ===
    vec3 F0 = calculateF0(albedo, metallic, mat.ior);
    vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);
    vec3 kS = F;
    vec3 kD = (1.0 - kS) * (1.0 - metallic);
    
    // Diffuse IBL (irradiance)
    vec3 ambientDiffuse = getSkyColor(N) * albedo * kD;
    
    // Specular IBL (pre-filtered environment)
    vec3 R = reflect(-V, N);
    vec3 ambientSpecular = getSpecularIBL(R, roughness) * F;
    
    result += (ambientDiffuse + ambientSpecular) * mat.occlusionStrength;
    
    // === Clearcoat ===
    if (mat.clearcoat > 0.0) {
        result += evaluateClearcoat(mat.clearcoat, mat.clearcoatRoughness, N, V, lightDir) * lightColor;
    }
    
    // === Emissive ===
    result += mat.emissiveFactor * mat.emissiveIntensity;
    
    return result;
}

// ============================================
// Lensing quality settings from uniforms (with fallback defaults)
int getMaxSteps() { return u_LensingSettings.x > 0.0 ? int(u_LensingSettings.x) : 64; }
float getStepSize() { return u_LensingSettings.y > 0.0 ? u_LensingSettings.y : 0.4; }
int getBvhCheckInterval() { return u_LensingSettings.z > 0.0 ? int(u_LensingSettings.z) : 6; }
float getMaxDistance() { return u_LensingSettings.w > 0.0 ? u_LensingSettings.w : 200.0; }

// ============================================
// Schwarzschild Geodesic Integration
// ============================================

// Calculate gravitational acceleration for light ray bending
// Using the geodesic equation for Schwarzschild metric
vec3 schwarzschildAcceleration(vec3 pos, vec3 vel, float rs) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    
    if (rMag < rs * 0.5) {
        return vec3(0.0); // Inside event horizon
    }
    
    // Angular momentum (cross product of position and velocity)
    vec3 h = cross(r, vel);
    float h2 = dot(h, h);
    
    // Schwarzschild geodesic acceleration
    // d²r/dλ² = -1.5 * rs * h² / r⁵ * r_hat
    float r5 = rMag * rMag * rMag * rMag * rMag;
    vec3 accel = -1.5 * rs * h2 / r5 * r;
    
    return accel;
}

// ============================================
// Kerr (Rotating) Black Hole Geodesic
// ============================================

// Calculate frame dragging angular velocity (omega) for Kerr metric
// omega = 2Mar / ((r^2 + a^2)^2 - a^2 * Delta * sin^2(theta))
// where Delta = r^2 - 2Mr + a^2
float frameDraggingOmega(float r, float theta, float M, float a) {
    if (r < M * 0.5) return 0.0; // Inside singularity region
    
    float r2 = r * r;
    float a2 = a * a;
    float Delta = r2 - 2.0 * M * r + a2;
    float sinTheta = sin(theta);
    float sin2Theta = sinTheta * sinTheta;
    
    // Sigma = r^2 + a^2 * cos^2(theta)
    float cosTheta = cos(theta);
    float Sigma = r2 + a2 * cosTheta * cosTheta;
    
    // Denominator: (r^2 + a^2)^2 - a^2 * Delta * sin^2(theta)
    float rpa2 = r2 + a2;
    float denom = rpa2 * rpa2 - a2 * Delta * sin2Theta;
    
    if (abs(denom) < 1e-10) return 0.0;
    
    return 2.0 * M * a * r / denom;
}

// Calculate gravitational acceleration for Kerr metric with frame dragging
// This combines the Schwarzschild-like radial attraction with azimuthal frame dragging
vec3 kerrAcceleration(vec3 pos, vec3 vel, float rs, float a, vec3 spinAxis) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    float M = rs * 0.5; // Mass in geometric units (rs = 2M)
    
    // Use outer horizon radius if available, else compute from rs and a
    float rPlus = u_OuterHorizonRadius > 0.0 ? u_OuterHorizonRadius : (M + sqrt(max(M*M - a*a, 0.0)));
    
    if (rMag < rPlus * 0.5) {
        return vec3(0.0); // Inside event horizon
    }
    
    // Start with Schwarzschild-like acceleration
    vec3 h = cross(r, vel);
    float h2 = dot(h, h);
    float r5 = rMag * rMag * rMag * rMag * rMag;
    vec3 accelRadial = -1.5 * rs * h2 / r5 * r;
    
    // If no spin, return pure Schwarzschild
    if (abs(a) < 1e-10) {
        return accelRadial;
    }
    
    // Calculate theta (angle from spin axis)
    vec3 rNorm = r / rMag;
    float cosTheta = dot(rNorm, spinAxis);
    float theta = acos(clamp(cosTheta, -1.0, 1.0));
    
    // Frame dragging angular velocity
    float omega = frameDraggingOmega(rMag, theta, M, a);
    
    // Frame dragging velocity: v_drag = omega * (spinAxis x r)
    // This is the velocity that local inertial frames are dragged with
    vec3 dragDirection = cross(spinAxis, rNorm);
    float dragDirLen = length(dragDirection);
    
    if (dragDirLen > 1e-6) {
        dragDirection /= dragDirLen;
        
        // The frame dragging "pulls" the light ray azimuthally
        // Acceleration toward the dragging direction
        float dragStrength = omega * rMag * sin(theta);
        
        // Scale by distance factor (stronger closer to black hole)
        float distFactor = rs / (rMag * rMag);
        distFactor = min(distFactor, 1.0);
        
        vec3 accelDrag = dragDirection * dragStrength * distFactor;
        
        return accelRadial + accelDrag;
    }
    
    return accelRadial;
}

// Check if position is inside the ergosphere
// Ergosphere radius: r_ergo = M + sqrt(M^2 - a^2 * cos^2(theta))
bool isInsideErgosphere(vec3 pos, float M, float a, vec3 spinAxis) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    
    vec3 rNorm = r / rMag;
    float cosTheta = dot(rNorm, spinAxis);
    float cos2Theta = cosTheta * cosTheta;
    
    float ergoRadius = M + sqrt(max(M*M - a*a * cos2Theta, 0.0));
    return rMag < ergoRadius;
}

// Calculate ergosphere radius at given theta angle
float ergosphereRadiusAtTheta(float M, float a, float cosTheta) {
    float cos2Theta = cosTheta * cosTheta;
    return M + sqrt(max(M*M - a*a * cos2Theta, 0.0));
}

// Get the "ergosphere distance" - how far inside/outside the ergosphere
// Negative = inside, Positive = outside
float ergosphereDistance(vec3 pos, float M, float a, vec3 spinAxis) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    if (rMag < 0.001) return -M; // At center
    
    vec3 rNorm = r / rMag;
    float cosTheta = dot(rNorm, spinAxis);
    float ergoRadius = ergosphereRadiusAtTheta(M, a, cosTheta);
    
    return rMag - ergoRadius;
}

// Ergosphere visualization color based on depth and angle
// Creates a translucent blue-purple shell effect
vec3 ergosphereColor(vec3 pos, float M, float a, vec3 spinAxis) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    if (rMag < 0.001) return vec3(0.0);
    
    vec3 rNorm = r / rMag;
    float cosTheta = dot(rNorm, spinAxis);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
    // Ergosphere is largest at equator, smallest at poles
    float ergoRadius = ergosphereRadiusAtTheta(M, a, cosTheta);
    float horizonRadius = M + sqrt(max(M*M - a*a, 0.0));
    
    // Depth into ergosphere (0 at boundary, 1 at horizon)
    float depth = 1.0 - (rMag - horizonRadius) / (ergoRadius - horizonRadius);
    depth = clamp(depth, 0.0, 1.0);
    
    // Color gradient: blue at boundary -> purple -> red near horizon
    vec3 boundaryColor = vec3(0.2, 0.4, 1.0);  // Blue
    vec3 midColor = vec3(0.6, 0.2, 0.8);       // Purple  
    vec3 deepColor = vec3(1.0, 0.2, 0.3);      // Red
    
    vec3 color;
    if (depth < 0.5) {
        color = mix(boundaryColor, midColor, depth * 2.0);
    } else {
        color = mix(midColor, deepColor, (depth - 0.5) * 2.0);
    }
    
    // Brighter at equator where ergosphere is largest
    float equatorFactor = sinTheta * sinTheta;
    color *= 0.5 + 0.5 * equatorFactor;
    
    // Add some swirl pattern based on frame dragging
    float angle = atan(r.z - u_BlackHolePos.z, r.x - u_BlackHolePos.x);
    float swirl = sin(angle * 4.0 + u_Time * 2.0) * 0.15 + 0.85;
    color *= swirl;
    
    return color;
}

// ============================================
// Photon Sphere Visualization
// ============================================

// Check if position is near the photon sphere (unstable photon orbit)
// For Kerr, photon sphere varies with latitude - use average
bool isNearPhotonSphere(vec3 pos, float photonR, float tolerance) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    return abs(rMag - photonR) < tolerance;
}

// Photon sphere visualization color - golden/yellow glow
vec3 photonSphereColor(vec3 pos, float photonR) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    
    // Distance from photon sphere surface
    float dist = abs(rMag - photonR);
    float thickness = photonR * 0.15; // Shell thickness
    
    // Intensity falls off with distance from photon sphere
    float intensity = 1.0 - clamp(dist / thickness, 0.0, 1.0);
    intensity = intensity * intensity; // Sharper falloff
    
    // Golden color for photon sphere - represents trapped light
    vec3 color = vec3(1.0, 0.85, 0.3) * intensity;
    
    // Add subtle pulsing effect
    float pulse = sin(u_Time * 3.0) * 0.1 + 0.9;
    color *= pulse;
    
    return color;
}

// ============================================
// Ring Singularity (Kerr)
// ============================================

// For Kerr black holes, the singularity is a ring of radius a in the equatorial plane
// Calculate distance to the ring singularity
float distanceToRingSingularity(vec3 pos, float a, vec3 spinAxis) {
    if (a < 0.001) return length(pos - u_BlackHolePos); // Point singularity for Schwarzschild
    
    vec3 r = pos - u_BlackHolePos;
    
    // Project position onto spin axis to get height
    float height = dot(r, spinAxis);
    
    // Get position in equatorial plane
    vec3 inPlane = r - height * spinAxis;
    float rho = length(inPlane); // Cylindrical radius
    
    // Distance to the ring (radius a, in equatorial plane)
    // Ring is at rho = a, height = 0
    float dRho = rho - a;
    float dHeight = height;
    
    return sqrt(dRho * dRho + dHeight * dHeight);
}

// Check if ray passes through the ring singularity plane near the ring
bool passedThroughRing(vec3 oldPos, vec3 newPos, float a, vec3 spinAxis, out vec3 ringHitPos) {
    if (a < 0.001) {
        ringHitPos = vec3(0.0);
        return false; // No ring for Schwarzschild
    }
    
    // Check if crossed equatorial plane
    float h1 = dot(oldPos - u_BlackHolePos, spinAxis);
    float h2 = dot(newPos - u_BlackHolePos, spinAxis);
    
    if (h1 * h2 >= 0.0) {
        ringHitPos = vec3(0.0);
        return false; // Didn't cross plane
    }
    
    // Find crossing point
    float t = abs(h1) / (abs(h1) + abs(h2));
    ringHitPos = mix(oldPos, newPos, t);
    
    // Check if crossing is within ring radius (with some tolerance)
    vec3 toHit = ringHitPos - u_BlackHolePos;
    vec3 inPlane = toHit - dot(toHit, spinAxis) * spinAxis;
    float rho = length(inPlane);
    
    // Ring has some thickness for visualization
    float ringThickness = a * 0.3;
    return abs(rho - a) < ringThickness;
}

// Ring singularity visualization - eerie purple/white glow
vec3 ringSingularityColor(vec3 pos, float a, vec3 spinAxis) {
    float dist = distanceToRingSingularity(pos, a, spinAxis);
    
    // Intensity increases dramatically near the ring
    float intensity = a / (dist + 0.01);
    intensity = clamp(intensity, 0.0, 10.0);
    
    // Purple-white color for the ring singularity
    vec3 color = mix(vec3(0.6, 0.3, 1.0), vec3(1.0, 1.0, 1.0), clamp(intensity * 0.1, 0.0, 1.0));
    
    // Flicker effect near singularity
    float flicker = sin(u_Time * 10.0 + dist * 5.0) * 0.2 + 0.8;
    
    return color * intensity * flicker * 0.5;
}

// ============================================
// Accretion Disk
// ============================================

// Calculate Keplerian orbital velocity at radius r around a Kerr black hole
// Returns velocity as fraction of speed of light
float diskOrbitalVelocity(float r, float M, float a) {
    // For Kerr metric, orbital velocity depends on spin
    // Simplified: v = sqrt(M/r) * (1 + a*sqrt(M/r^3)) for prograde
    float v_kepler = sqrt(M / r);
    
    // Frame dragging boost for prograde orbits
    float frameDragBoost = 1.0 + 0.5 * a * sqrt(M / (r * r * r));
    
    // Clamp to reasonable relativistic values (max ~0.5c for visible disk)
    return clamp(v_kepler * frameDragBoost, 0.0, 0.5);
}

// Calculate orbital period at radius r (for animation)
float diskOrbitalPeriod(float r, float M) {
    // T = 2*pi*sqrt(r^3/M) in geometric units
    return 6.283185 * sqrt(r * r * r / M);
}

// Calculate Doppler factor for relativistic beaming
// D = 1 / (gamma * (1 - beta * cos(theta)))
float dopplerFactor(float beta, float cosTheta) {
    if (abs(beta) < 0.001) return 1.0;
    
    float gamma = 1.0 / sqrt(1.0 - beta * beta);
    float D = 1.0 / (gamma * (1.0 - beta * cosTheta));
    
    return clamp(D, 0.1, 5.0);
}

// Calculate gravitational redshift factor
// z = 1/sqrt(1 - rs/r) - 1 for Schwarzschild
// Light from deeper in gravity well is redshifted (loses energy)
float gravitationalRedshift(float r, float rs) {
    if (r <= rs) return 10.0; // Extreme redshift near horizon
    float factor = sqrt(1.0 - rs / r);
    return 1.0 / factor; // >1 means redshifted, energy reduced
}

// Apply relativistic Doppler color shift
vec3 dopplerColorShift(vec3 baseColor, float dopplerD) {
    if (abs(dopplerD - 1.0) < 0.01) return baseColor;
    
    float shift = dopplerD - 1.0;
    
    vec3 blueShift = vec3(0.8, 0.9, 1.0);
    vec3 redShift = vec3(1.0, 0.7, 0.5);
    
    if (shift > 0.0) {
        float amount = clamp(shift * 0.5, 0.0, 0.6);
        return mix(baseColor, baseColor * blueShift, amount);
    } else {
        float amount = clamp(-shift * 0.5, 0.0, 0.6);
        return mix(baseColor, baseColor * redShift, amount);
    }
}

// Apply gravitational redshift to color
vec3 applyGravitationalRedshift(vec3 baseColor, float redshiftFactor) {
    // Redshift moves colors toward red and reduces intensity
    float intensity = 1.0 / redshiftFactor;
    
    // Subtle color shift toward red for gravitationally redshifted light
    float colorShift = clamp((redshiftFactor - 1.0) * 0.3, 0.0, 0.5);
    vec3 redshiftTint = vec3(1.0, 0.85, 0.7);
    
    return mix(baseColor, baseColor * redshiftTint, colorShift) * intensity;
}

// Calculate disk thickness at given radius
// Disk is thicker at outer edge, thinner near ISCO
float getDiskThickness(float r, float innerR, float outerR, float maxThickness) {
    float t = (r - innerR) / (outerR - innerR);
    t = clamp(t, 0.0, 1.0);
    // Thickness increases with radius (flared disk)
    return maxThickness * (0.3 + 0.7 * t);
}

// Temperature-based color for accretion disk with full relativistic effects
vec3 diskColor(vec3 hitPos, float rs) {
    // Get disk-plane position relative to black hole
    vec3 diskNormal = length(u_BlackHoleSpinAxis) > 0.5 ? normalize(u_BlackHoleSpinAxis) : vec3(0.0, 1.0, 0.0);
    vec3 toHit = hitPos - u_BlackHolePos;
    vec3 inPlane = toHit - dot(toHit, diskNormal) * diskNormal;
    float distFromCenter = length(inPlane);
    
    // Use ISCO as inner radius if available
    float innerRadius = u_DiskISCO > 0.0 ? u_DiskISCO : u_DiskInnerRadius;
    float outerRadius = u_DiskOuterRadius;
    
    // Temperature decreases with distance from center
    float t = (distFromCenter - innerRadius) / (outerRadius - innerRadius);
    t = clamp(t, 0.0, 1.0);
    
    // Inner disk is hotter (bluer/whiter), outer is cooler (redder)
    vec3 hotColor = vec3(1.0, 0.95, 0.9);  // White-hot
    vec3 warmColor = vec3(1.0, 0.6, 0.2);  // Orange
    vec3 coolColor = vec3(0.8, 0.2, 0.1);  // Red
    
    vec3 color;
    if (t < 0.5) {
        color = mix(hotColor, warmColor, t * 2.0);
    } else {
        color = mix(warmColor, coolColor, (t - 0.5) * 2.0);
    }
    
    // Base brightness from gravitational heating (closer = brighter)
    // Energy release ~ 1/r for accretion
    float brightness = 1.0 / (1.0 + t * t * 3.0);
    
    float M = rs * 0.5;
    float a = u_KerrParameter;
    float spin = u_BlackHoleSpin;
    
    // === GRAVITATIONAL REDSHIFT ===
    // Light from inner disk loses energy climbing out of gravity well
    float gRedshift = gravitationalRedshift(distFromCenter, rs);
    color = applyGravitationalRedshift(color, gRedshift);
    
    // === DOPPLER BEAMING ===
    if (abs(spin) > 0.001 && distFromCenter > 0.01) {
        float orbitalSpeed = diskOrbitalVelocity(distFromCenter, M, a);
        
        vec3 radialDir = normalize(inPlane);
        vec3 orbitalDir = cross(diskNormal, radialDir);
        
        vec3 toCamera = normalize(u_CameraPos - hitPos);
        float cosTheta = dot(orbitalDir, toCamera);
        
        float D = dopplerFactor(orbitalSpeed, cosTheta);
        
        // Relativistic beaming: D^3 for surface brightness
        float beaming = D * D * D;
        brightness *= beaming;
        
        // Doppler color shift
        color = dopplerColorShift(color, D);
    }
    
    // === DISK ROTATION ANIMATION ===
    vec3 radial = length(inPlane) > 0.01 ? normalize(inPlane) : vec3(1.0, 0.0, 0.0);
    float baseAngle = atan(radial.z, radial.x);
    
    // Orbital motion - inner disk rotates faster
    float period = diskOrbitalPeriod(distFromCenter, M);
    float orbitalPhase = u_Time / max(period, 0.1);
    float animatedAngle = baseAngle + orbitalPhase * 6.283185;
    
    // Turbulence pattern that rotates with the disk
    float turbulence = sin(animatedAngle * 8.0) * 0.12 + 0.88;
    
    // Add spiral arm structure
    float spiral = sin(animatedAngle * 2.0 - distFromCenter * 0.5) * 0.08 + 0.92;
    
    return color * brightness * turbulence * spiral * 2.5;
}

// Check if a point is inside the disk volume (for thickness)
bool isInsideDiskVolume(vec3 pos, vec3 diskNormal, float innerR, float outerR, float maxThickness) {
    vec3 toPos = pos - u_BlackHolePos;
    float heightAboveDisk = abs(dot(toPos, diskNormal));
    vec3 inPlane = toPos - dot(toPos, diskNormal) * diskNormal;
    float r = length(inPlane);
    
    if (r < innerR || r > outerR) return false;
    
    float thickness = getDiskThickness(r, innerR, outerR, maxThickness);
    return heightAboveDisk <= thickness;
}

// ============================================
// Volumetric Light Scattering
// ============================================

// Calculate volumetric scattering contribution along a ray
// This simulates light scattering through dust/gas near the black hole
vec3 volumetricScattering(vec3 rayOrigin, vec3 rayDir, float maxDist, float rs) {
    if (rs <= 0.0) return vec3(0.0); // No black hole, no scattering
    
    vec3 scatterColor = vec3(0.0);
    float scatterDensity = 0.0;
    
    int numSteps = 16;
    float stepSize = min(maxDist, rs * 15.0) / float(numSteps);
    
    vec3 diskNormal = length(u_BlackHoleSpinAxis) > 0.5 ? normalize(u_BlackHoleSpinAxis) : vec3(0.0, 1.0, 0.0);
    float innerRadius = u_DiskISCO > 0.0 ? u_DiskISCO : u_DiskInnerRadius;
    float outerRadius = u_DiskOuterRadius;
    
    for (int i = 0; i < numSteps; i++) {
        float t = (float(i) + 0.5) * stepSize;
        vec3 samplePos = rayOrigin + rayDir * t;
        
        // Distance from black hole
        vec3 toSample = samplePos - u_BlackHolePos;
        float distFromBH = length(toSample);
        
        // Height above disk plane
        float heightAboveDisk = abs(dot(toSample, diskNormal));
        
        // Radial distance in disk plane
        vec3 inPlane = toSample - dot(toSample, diskNormal) * diskNormal;
        float radialDist = length(inPlane);
        
        // Skip if inside event horizon
        if (distFromBH < rs) continue;
        
        // Scattering medium density falls off with distance from disk
        // and with radial distance from optimal disk region
        float diskProximity = 0.0;
        if (radialDist > innerRadius * 0.5 && radialDist < outerRadius * 1.5) {
            // Exponential falloff from disk plane
            float diskHeight = rs * 0.5;
            diskProximity = exp(-heightAboveDisk * heightAboveDisk / (diskHeight * diskHeight));
            
            // Radial distribution - peaks in middle of disk
            float radialT = (radialDist - innerRadius) / (outerRadius - innerRadius);
            radialT = clamp(radialT, 0.0, 1.0);
            float radialDensity = sin(radialT * PI) * 0.5 + 0.5;
            diskProximity *= radialDensity;
        }
        
        // Add scattered light contribution
        if (diskProximity > 0.01) {
            // Color from disk emission (approximate)
            vec3 emissionColor = mix(vec3(1.0, 0.6, 0.2), vec3(1.0, 0.9, 0.8), 
                                     clamp(1.0 - radialDist / outerRadius, 0.0, 1.0));
            
            // Phase function - forward scattering bias (Henyey-Greenstein approximation)
            float g = 0.7; // Forward scattering
            vec3 toLight = normalize(u_BlackHolePos - samplePos);
            float cosAngle = dot(rayDir, toLight);
            float phase = (1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * cosAngle, 1.5) / (4.0 * PI);
            
            // Accumulate scattering
            float localDensity = diskProximity * 0.02;
            scatterColor += emissionColor * phase * localDensity * stepSize;
            scatterDensity += localDensity * stepSize;
        }
    }
    
    // Apply atmospheric attenuation
    float attenuation = exp(-scatterDensity * 2.0);
    return scatterColor * (1.0 - attenuation);
}

// God ray effect - light streaming from bright disk regions
vec3 godRays(vec3 rayOrigin, vec3 rayDir, float rs) {
    if (rs <= 0.0) return vec3(0.0);
    
    // Check if ray passes near the accretion disk region
    vec3 toBH = u_BlackHolePos - rayOrigin;
    float closestApproach = length(cross(toBH, rayDir));
    float outerRadius = u_DiskOuterRadius;
    
    if (closestApproach > outerRadius * 2.0) return vec3(0.0);
    
    // Sample along ray for god ray contribution
    vec3 godRayColor = vec3(0.0);
    int numSamples = 8;
    float maxT = length(toBH) + outerRadius * 2.0;
    
    for (int i = 0; i < numSamples; i++) {
        float t = (float(i) + 0.5) / float(numSamples) * maxT;
        vec3 samplePos = rayOrigin + rayDir * t;
        
        vec3 toSample = samplePos - u_BlackHolePos;
        float dist = length(toSample);
        
        if (dist < rs || dist > outerRadius * 1.5) continue;
        
        // Light intensity based on proximity to disk
        float innerR = u_DiskISCO > 0.0 ? u_DiskISCO : u_DiskInnerRadius;
        float radialDist = length(toSample - dot(toSample, vec3(0.0, 1.0, 0.0)) * vec3(0.0, 1.0, 0.0));
        
        if (radialDist >= innerR && radialDist <= outerRadius) {
            float radialT = (radialDist - innerR) / (outerRadius - innerR);
            float intensity = exp(-radialT * 2.0) * 0.1;
            
            // Warm glow color
            vec3 glowColor = mix(vec3(1.0, 0.8, 0.5), vec3(1.0, 0.5, 0.2), radialT);
            godRayColor += glowColor * intensity / float(numSamples);
        }
    }
    
    return godRayColor;
}

// ============================================
// Procedural Starfield
// ============================================

// Simple hash function for procedural generation
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float hash3(vec3 p) {
    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453);
}

vec2 rand2(vec2 p) {
    return vec2(
        hash(p + vec2(11.3, 17.7)),
        hash(p + vec2(31.7, 47.9))
    );
}

// Halton sequence for better quasi-random sampling (reduces noise)
float halton(int index, int base) {
    float f = 1.0;
    float r = 0.0;
    int i = index;
    while (i > 0) {
        f /= float(base);
        r += f * float(i % base);
        i /= base;
    }
    return r;
}

// Blue noise-like distribution for TAA jitter
vec2 taaJitter(int frameIdx, int sampleIdx) {
    // Use Halton sequence bases 2 and 3 for good 2D distribution
    int idx = frameIdx * 8 + sampleIdx;
    return vec2(halton(idx + 1, 2), halton(idx + 1, 3)) - 0.5;
}

bool intersectAabb(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax, out float tmin, out float tmax) {
    vec3 inv = 1.0 / rd;
    vec3 t0 = (bmin - ro) * inv;
    vec3 t1 = (bmax - ro) * inv;
    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);
    tmin = max(max(tmin3.x, tmin3.y), max(tmin3.z, 0.0));
    tmax = min(min(tmax3.x, tmax3.y), tmax3.z);
    return tmax >= tmin;
}

// Triangle intersection with barycentric coordinates output
// Returns t (distance), u and v (barycentric coords where w = 1-u-v)
bool intersectTriangle(vec3 ro, vec3 rd, GpuTriangle tri, out float t, out float u, out float v) {
    vec3 v0v1 = tri.v1 - tri.v0;
    vec3 v0v2 = tri.v2 - tri.v0;
    vec3 pvec = cross(rd, v0v2);
    float det = dot(v0v1, pvec);
    if (abs(det) < 1e-6) {
        t = 0.0; u = 0.0; v = 0.0;
        return false;
    }
    float invDet = 1.0 / det;
    vec3 tvec = ro - tri.v0;
    u = dot(tvec, pvec) * invDet;
    if (u < 0.0 || u > 1.0) {
        t = 0.0; v = 0.0;
        return false;
    }
    vec3 qvec = cross(tvec, v0v1);
    v = dot(rd, qvec) * invDet;
    if (v < 0.0 || u + v > 1.0) {
        t = 0.0;
        return false;
    }
    t = dot(v0v2, qvec) * invDet;
    return t > 0.0001;
}

// Interpolate UV coordinates using barycentric coordinates
vec2 interpolateUV(GpuTriangle tri, float u, float v) {
    float w = 1.0 - u - v;
    return w * tri.uv0 + u * tri.uv1 + v * tri.uv2;
}

// Interpolate tangent for normal mapping
vec4 interpolateTangent(GpuTriangle tri, float u, float v) {
    // For now, use face tangent (tangent is per-triangle not per-vertex in our struct)
    return tri.tangent;
}

// Hit info structure for BVH traversal
struct HitInfo {
    float t;
    float u;
    float v;
    int triIndex;
    vec3 normal;
};

bool intersectBvh(vec3 ro, vec3 rd, int nodeCount, int triCount, out vec3 hitPos, out vec3 hitNormal, out vec3 hitColor) {
    if (nodeCount == 0 || triCount == 0) return false;

    HitInfo closest;
    closest.t = 1e20;
    closest.triIndex = -1;
    bool hit = false;

    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        int nodeIndex = stack[--stackPtr];
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;
        BvhNode node = bvhNodes[nodeIndex];

        float tmin;
        float tmax;
        if (!intersectAabb(ro, rd, node.boundsMin, node.boundsMax, tmin, tmax) || tmin > closest.t) {
            continue;
        }

        if (node.triCount > 0) {
            int first = node.leftFirst;
            for (int i = 0; i < node.triCount; i++) {
                int triIndex = first + i;
                if (triIndex < 0 || triIndex >= triCount) continue;
                GpuTriangle tri = triangles[triIndex];
                float t, u, v;
                if (intersectTriangle(ro, rd, tri, t, u, v) && t < closest.t) {
                    closest.t = t;
                    closest.u = u;
                    closest.v = v;
                    closest.triIndex = triIndex;
                    closest.normal = tri.normal;
                    hit = true;
                }
            }
        } else {
            int left = node.leftFirst;
            int right = left + 1;
            if (right < nodeCount && stackPtr < 63) stack[stackPtr++] = right;
            if (left < nodeCount && stackPtr < 63) stack[stackPtr++] = left;
        }
    }

    if (hit && closest.triIndex >= 0) {
        hitPos = ro + rd * closest.t;
        hitNormal = closest.normal;
        GpuTriangle hitTri = triangles[closest.triIndex];
        
        // Interpolate UV coordinates
        vec2 uv = interpolateUV(hitTri, closest.u, closest.v);
        
        // Use PBR shading with proper UVs
        vec3 viewDir = -rd; // Direction toward camera
        hitColor = shadePBRWithUV(hitPos, hitNormal, viewDir, hitTri, uv);
    }
    return hit;
}

// Procedural starfield fallback (used if env map is black/empty)
vec3 proceduralStarfield(vec3 dir) {
    // Normalize direction
    dir = normalize(dir);
    
    // Convert direction to spherical coordinates
    float phi = atan(dir.z, dir.x);
    float theta = asin(clamp(dir.y, -1.0, 1.0));
    
    // Create a grid on the sphere
    vec2 grid = vec2(phi, theta) * 50.0;
    vec2 gridId = floor(grid);
    vec2 gridUv = fract(grid);
    
    // Random star position within cell
    vec2 starPos = vec2(hash(gridId), hash(gridId + 100.0));
    float starDist = length(gridUv - starPos);
    
    // Star brightness based on random value
    float starBrightness = hash(gridId + 200.0);
    
    // Background - dark space
    vec3 bgColor = vec3(0.0, 0.0, 0.02);
    
    // Stars - more of them and brighter
    if (starBrightness > 0.92) {
        float star = smoothstep(0.08, 0.0, starDist);
        
        // Star color variation
        vec3 starColor = vec3(1.0);
        float colorRand = hash(gridId + 300.0);
        if (colorRand < 0.3) {
            starColor = vec3(1.0, 0.9, 0.7); // Warm yellow
        } else if (colorRand < 0.6) {
            starColor = vec3(0.7, 0.8, 1.0); // Cool blue
        }
        
        float intensity = (starBrightness - 0.92) * 12.0;
        return bgColor + starColor * star * intensity;
    }
    
    return bgColor;
}

// Sample sky/environment - uses environment map with procedural fallback
vec3 starfield(vec3 dir) {
    // Sample environment map
    vec3 envColor = sampleEnvironment(dir);
    
    // Check if environment map has content (not pure black)
    float envBrightness = dot(envColor, vec3(0.299, 0.587, 0.114));
    
    // If environment is very dark, add procedural stars
    if (envBrightness < 0.01) {
        return proceduralStarfield(dir);
    }
    
    return envColor;
}

// ============================================
// Main Raytracing
// ============================================

// Simple ray-sphere intersection for the event horizon visualization
float intersectSphere(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b * b - c;
    if (h < 0.0) return -1.0;
    return -b - sqrt(h);
}

// Check BVH intersection for a short ray segment (used during geodesic tracing)
bool intersectBvhSegment(vec3 ro, vec3 rd, float maxDist, int nodeCount, int triCount, 
                          out float hitT, out vec3 hitNormal, out vec3 hitColor) {
    if (nodeCount == 0 || triCount == 0) return false;

    HitInfo closest;
    closest.t = maxDist;
    closest.triIndex = -1;
    bool hit = false;

    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        int nodeIndex = stack[--stackPtr];
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;
        BvhNode node = bvhNodes[nodeIndex];

        float tmin, tmax;
        if (!intersectAabb(ro, rd, node.boundsMin, node.boundsMax, tmin, tmax) || tmin > closest.t) {
            continue;
        }

        if (node.triCount > 0) {
            int first = node.leftFirst;
            for (int i = 0; i < node.triCount; i++) {
                int triIndex = first + i;
                if (triIndex < 0 || triIndex >= triCount) continue;
                GpuTriangle tri = triangles[triIndex];
                float t, u, v;
                if (intersectTriangle(ro, rd, tri, t, u, v) && t < closest.t && t > 0.001) {
                    closest.t = t;
                    closest.u = u;
                    closest.v = v;
                    closest.triIndex = triIndex;
                    closest.normal = tri.normal;
                    hit = true;
                }
            }
        } else {
            int left = node.leftFirst;
            int right = left + 1;
            if (right < nodeCount && stackPtr < 63) stack[stackPtr++] = right;
            if (left < nodeCount && stackPtr < 63) stack[stackPtr++] = left;
        }
    }

    if (hit && closest.triIndex >= 0) {
        hitT = closest.t;
        hitNormal = closest.normal;
        vec3 hitPos = ro + rd * closest.t;
        GpuTriangle hitTri = triangles[closest.triIndex];
        
        // Interpolate UV coordinates
        vec2 uv = interpolateUV(hitTri, closest.u, closest.v);
        
        // Use PBR shading with proper UVs
        vec3 viewDir = -rd;
        hitColor = shadePBRWithUV(hitPos, hitNormal, viewDir, hitTri, uv);
    }
    return hit;
}

bool traceOnce(vec3 rayOrigin, vec3 rayDir, out vec3 outColor, out vec3 hitPos, out vec3 hitNormal) {
    int nodeCount = int(u_RaySettings.z + 0.5);
    int triCount = int(u_RaySettings.w + 0.5);
    
    float rs = u_SchwarzschildRadius;
    
    // Kerr black hole parameters
    float a = u_KerrParameter;                    // Kerr parameter (spin in geometric units)
    float spin = u_BlackHoleSpin;                 // Dimensionless spin (0 to ~1)
    vec3 spinAxis = normalize(u_BlackHoleSpinAxis);
    float eventHorizon = u_OuterHorizonRadius > 0.0 ? u_OuterHorizonRadius : rs;
    bool useKerr = abs(spin) > 0.001;             // Use Kerr geodesics if spinning
    
    // If no black hole (rs <= 0), use simple straight-line BVH intersection
    if (rs <= 0.0) {
        vec3 hitColor;
        if (intersectBvh(rayOrigin, rayDir, nodeCount, triCount, hitPos, hitNormal, hitColor)) {
            outColor = hitColor;
            return true;
        }
        outColor = starfield(rayDir);
        hitPos = rayOrigin + rayDir * 100.0;
        hitNormal = vec3(0.0, 1.0, 0.0);
        return false;
    }

    // Quick distance check - if ray starts far from black hole and points away, use simple trace
    vec3 toBH = u_BlackHolePos - rayOrigin;
    float distToBH = length(toBH);
    float dotDir = dot(normalize(toBH), rayDir);
    
    // If far from black hole and not pointing toward it, skip geodesic tracing
    if (distToBH > rs * 20.0 && dotDir < 0.3) {
        vec3 hitColor;
        if (intersectBvh(rayOrigin, rayDir, nodeCount, triCount, hitPos, hitNormal, hitColor)) {
            outColor = hitColor;
            return true;
        }
        outColor = starfield(rayDir);
        hitPos = rayOrigin + rayDir * 100.0;
        hitNormal = vec3(0.0, 1.0, 0.0);
        return false;
    }

    // Get quality settings from uniforms
    int maxSteps = getMaxSteps();
    float baseStepSize = getStepSize();
    int bvhInterval = getBvhCheckInterval();
    float maxDistance = getMaxDistance();
    
    // Trace ray along curved geodesic path
    vec3 pos = rayOrigin;
    vec3 vel = normalize(rayDir);
    float totalDist = 0.0;
    
    // Visualization accumulation
    float M = rs * 0.5; // Mass in geometric units
    bool showErgo = u_ShowErgosphere > 0.5 && useKerr;
    bool showPhoton = u_ShowPhotonSphere > 0.5;
    float photonR = u_PhotonSphereRadius > 0.0 ? u_PhotonSphereRadius : 1.5 * rs;
    
    vec3 ergoColorAccum = vec3(0.0);
    float ergoDistAccum = 0.0;
    vec3 photonColorAccum = vec3(0.0);
    float photonDistAccum = 0.0;
    vec3 ringColorAccum = vec3(0.0);
    float ringDistAccum = 0.0;
    
    for (int i = 0; i < maxSteps; i++) {
        // Distance from current position to black hole center
        vec3 relPos = pos - u_BlackHolePos;
        float dist = length(relPos);
        
        // Adaptive step size - larger when far from black hole
        float step = baseStepSize * clamp(dist / (rs * 2.0), 0.1, 2.0);
        
        // Check if fallen into event horizon (use outer horizon for Kerr)
        if (dist < eventHorizon) {
            // Apply accumulated ergosphere color before returning black
            if (showErgo && ergoDistAccum > 0.0) {
                float ergoAlpha = min(ergoDistAccum * u_ErgosphereOpacity * 0.1, 0.8);
                outColor = ergoColorAccum / max(ergoDistAccum, 0.001) * ergoAlpha;
            } else {
                outColor = vec3(0.0); // Black - absorbed by black hole
            }
            hitPos = pos;
            hitNormal = vec3(0.0, 1.0, 0.0);
            return false;
        }
        
        // Ergosphere visualization - accumulate color while ray passes through
        if (showErgo) {
            bool insideErgo = isInsideErgosphere(pos, M, a, spinAxis);
            if (insideErgo) {
                vec3 eColor = ergosphereColor(pos, M, a, spinAxis);
                ergoColorAccum += eColor * step;
                ergoDistAccum += step;
            }
        }
        
        // Photon sphere visualization - accumulate when near photon orbit radius
        if (showPhoton) {
            float photonTolerance = photonR * 0.2;
            if (isNearPhotonSphere(pos, photonR, photonTolerance)) {
                vec3 pColor = photonSphereColor(pos, photonR);
                photonColorAccum += pColor * step;
                photonDistAccum += step;
            }
        }
        
        // Ring singularity visualization (Kerr only)
        if (useKerr && a > 0.01) {
            float ringDist = distanceToRingSingularity(pos, a, spinAxis);
            if (ringDist < a * 0.5) {
                vec3 rColor = ringSingularityColor(pos, a, spinAxis);
                ringColorAccum += rColor * step;
                ringDistAccum += step;
            }
        }
        
        // Only check BVH periodically to save performance (every N steps or when far from BH)
        bool checkBvh = (i % bvhInterval == 0) || (dist > rs * 8.0);
        
        if (checkBvh) {
            float hitT;
            vec3 segHitNormal, segHitColor;
            float checkDist = step * float(bvhInterval) * 1.2;
            if (intersectBvhSegment(pos, vel, checkDist, nodeCount, triCount, hitT, segHitNormal, segHitColor)) {
                hitPos = pos + vel * hitT;
                hitNormal = segHitNormal;
                outColor = segHitColor;
                
                // Blend visualization effects
                if (showErgo && ergoDistAccum > 0.0) {
                    float ergoAlpha = min(ergoDistAccum * u_ErgosphereOpacity * 0.1, 0.5);
                    outColor = mix(outColor, ergoColorAccum / ergoDistAccum, ergoAlpha);
                }
                if (showPhoton && photonDistAccum > 0.0) {
                    float photonAlpha = min(photonDistAccum * u_PhotonSphereOpacity * 0.15, 0.4);
                    outColor = mix(outColor, photonColorAccum / photonDistAccum, photonAlpha);
                }
                if (ringDistAccum > 0.0) {
                    float ringAlpha = min(ringDistAccum * 0.2, 0.5);
                    outColor += ringColorAccum / ringDistAccum * ringAlpha;
                }
                return true;
            }
        }
        
        // Store old position for disk intersection test
        vec3 oldPos = pos;
        
        // Calculate acceleration based on black hole type
        vec3 accel;
        if (useKerr) {
            // Use Kerr geodesic with frame dragging
            accel = kerrAcceleration(pos, vel, rs, a, spinAxis);
        } else {
            // Use simpler Schwarzschild approximation
            vec3 towardMass = -normalize(relPos);
            float bendStrength = rs * 1.5 / (dist * dist);
            bendStrength = min(bendStrength, 0.5);
            accel = towardMass * bendStrength;
        }
        
        vel += accel * step;
        vel = normalize(vel);
        pos = pos + vel * step;
        totalDist += step;
        
        // Check for accretion disk intersection
        // For Kerr black holes, disk is perpendicular to spin axis
        // For Schwarzschild, use Y-axis (spinAxis defaults to (0,1,0))
        vec3 diskNormal = useKerr ? spinAxis : vec3(0.0, 1.0, 0.0);
        
        // Signed distance from disk plane (plane passes through black hole center)
        float d1 = dot(oldPos - u_BlackHolePos, diskNormal);
        float d2 = dot(pos - u_BlackHolePos, diskNormal);
        
        // Use ISCO as inner radius if available, otherwise use uniform
        float diskInnerR = u_DiskISCO > 0.0 ? u_DiskISCO : u_DiskInnerRadius;
        float diskOuterR = u_DiskOuterRadius;
        float diskThick = u_DiskThickness > 0.0 ? u_DiskThickness : 0.0;
        
        // Check for disk intersection - either crossing plane or inside volume
        bool crossedPlane = (d1 * d2 < 0.0);
        bool insideDiskVolume = diskThick > 0.0 && isInsideDiskVolume(pos, diskNormal, diskInnerR, diskOuterR, diskThick);
        
        if (crossedPlane || insideDiskVolume) {
            vec3 diskHitPos;
            float distFromCenter;
            
            if (crossedPlane) {
                // Ray crossed the disk plane
                float t = abs(d1) / (abs(d1) + abs(d2));
                diskHitPos = mix(oldPos, pos, t);
                
                vec3 toDiskHit = diskHitPos - u_BlackHolePos;
                vec3 inPlane = toDiskHit - dot(toDiskHit, diskNormal) * diskNormal;
                distFromCenter = length(inPlane);
            } else {
                // Inside disk volume
                diskHitPos = pos;
                vec3 toDiskHit = diskHitPos - u_BlackHolePos;
                vec3 inPlane = toDiskHit - dot(toDiskHit, diskNormal) * diskNormal;
                distFromCenter = length(inPlane);
            }
            
            if (distFromCenter >= diskInnerR && distFromCenter <= diskOuterR) {
                outColor = diskColor(diskHitPos, rs);
                
                // For volumetric disk, attenuate based on path through disk
                if (insideDiskVolume && !crossedPlane) {
                    float thickness = getDiskThickness(distFromCenter, diskInnerR, diskOuterR, diskThick);
                    float heightInDisk = abs(dot(diskHitPos - u_BlackHolePos, diskNormal));
                    float density = 1.0 - (heightInDisk / thickness);
                    outColor *= density * 0.5;
                }
                
                // Blend visualization effects
                if (showErgo && ergoDistAccum > 0.0) {
                    float ergoAlpha = min(ergoDistAccum * u_ErgosphereOpacity * 0.1, 0.5);
                    outColor = mix(outColor, ergoColorAccum / ergoDistAccum, ergoAlpha);
                }
                if (showPhoton && photonDistAccum > 0.0) {
                    float photonAlpha = min(photonDistAccum * u_PhotonSphereOpacity * 0.15, 0.4);
                    outColor = mix(outColor, photonColorAccum / photonDistAccum, photonAlpha);
                }
                if (ringDistAccum > 0.0) {
                    float ringAlpha = min(ringDistAccum * 0.2, 0.5);
                    outColor += ringColorAccum / ringDistAccum * ringAlpha;
                }
                
                hitPos = diskHitPos;
                hitNormal = dot(vel, diskNormal) > 0.0 ? -diskNormal : diskNormal;
                return true;
            }
        }
        
        // Check if ray escaped (far from black hole or traveled far enough)
        if (dist > rs * 25.0 || totalDist > maxDistance) {
            // Do one final BVH check with full remaining distance before returning starfield
            float hitT;
            vec3 segHitNormal, segHitColor;
            float remainingDist = maxDistance * 2.0;
            if (intersectBvhSegment(pos, vel, remainingDist, nodeCount, triCount, hitT, segHitNormal, segHitColor)) {
                hitPos = pos + vel * hitT;
                hitNormal = segHitNormal;
                outColor = segHitColor;
                
                // Blend visualization effects
                if (showErgo && ergoDistAccum > 0.0) {
                    float ergoAlpha = min(ergoDistAccum * u_ErgosphereOpacity * 0.1, 0.5);
                    outColor = mix(outColor, ergoColorAccum / ergoDistAccum, ergoAlpha);
                }
                if (showPhoton && photonDistAccum > 0.0) {
                    float photonAlpha = min(photonDistAccum * u_PhotonSphereOpacity * 0.15, 0.4);
                    outColor = mix(outColor, photonColorAccum / photonDistAccum, photonAlpha);
                }
                if (ringDistAccum > 0.0) {
                    float ringAlpha = min(ringDistAccum * 0.2, 0.5);
                    outColor += ringColorAccum / ringDistAccum * ringAlpha;
                }
                return true;
            }
            
            // Blend visualization effects with starfield
            outColor = starfield(vel);
            
            // Add volumetric scattering contribution
            vec3 volumetric = volumetricScattering(rayOrigin, vel, totalDist, rs);
            vec3 godRayContrib = godRays(rayOrigin, vel, rs);
            outColor += volumetric + godRayContrib;
            
            if (showErgo && ergoDistAccum > 0.0) {
                float ergoAlpha = min(ergoDistAccum * u_ErgosphereOpacity * 0.1, 0.5);
                outColor = mix(outColor, ergoColorAccum / ergoDistAccum, ergoAlpha);
            }
            if (showPhoton && photonDistAccum > 0.0) {
                float photonAlpha = min(photonDistAccum * u_PhotonSphereOpacity * 0.15, 0.4);
                outColor = mix(outColor, photonColorAccum / photonDistAccum, photonAlpha);
            }
            if (ringDistAccum > 0.0) {
                float ringAlpha = min(ringDistAccum * 0.2, 0.5);
                outColor += ringColorAccum / ringDistAccum * ringAlpha;
            }
            
            hitPos = pos;
            hitNormal = vec3(0.0, 1.0, 0.0);
            return false;
        }
    }
    
    // Max iterations reached - return starfield based on final direction
    outColor = starfield(vel);
    
    // Add volumetric effects
    vec3 volumetric = volumetricScattering(rayOrigin, vel, totalDist, rs);
    vec3 godRayContrib = godRays(rayOrigin, vel, rs);
    outColor += volumetric + godRayContrib;
    
    // Blend visualization effects
    if (showErgo && ergoDistAccum > 0.0) {
        float ergoAlpha = min(ergoDistAccum * u_ErgosphereOpacity * 0.1, 0.5);
        outColor = mix(outColor, ergoColorAccum / ergoDistAccum, ergoAlpha);
    }
    if (showPhoton && photonDistAccum > 0.0) {
        float photonAlpha = min(photonDistAccum * u_PhotonSphereOpacity * 0.15, 0.4);
        outColor = mix(outColor, photonColorAccum / photonDistAccum, photonAlpha);
    }
    if (ringDistAccum > 0.0) {
        float ringAlpha = min(ringDistAccum * 0.2, 0.5);
        outColor += ringColorAccum / ringDistAccum * ringAlpha;
    }
    
    hitPos = pos;
    hitNormal = vec3(0.0, 1.0, 0.0);
    return false;
}

void main() {
    uvec3 gid = gl_GlobalInvocationID;
    ivec2 pixelCoord = ivec2(gid.xy);
    ivec2 resolution = ivec2(u_Resolution);
    
    // Bounds check
    if (pixelCoord.x >= resolution.x || pixelCoord.y >= resolution.y) {
        return;
    }
    
    int raysPerPixel = clamp(int(u_RaySettings.x + 0.5), 1, 64);
    int maxBounces = clamp(int(u_RaySettings.y + 0.5), 1, 8);
    int samplesPerFrame = clamp(int(u_FrameSettings.x + 0.5), 1, 8);
    int frameIndex = int(u_FrameSettings.y + 0.5);
    bool accumulateEnabled = u_FrameSettings.z > 0.5;
    bool denoiseEnabled = u_FrameSettings.w > 0.5;
    bool resetAccum = !accumulateEnabled || frameIndex == 0;

    vec3 color = vec3(0.0);
    
    // Calculate ray direction based on camera and FOV
    float fovRad = u_Fov * PI / 180.0;
    float tanHalfFov = tan(fovRad * 0.5);

    int totalSamples = raysPerPixel * samplesPerFrame;
    for (int sampleIndex = 0; sampleIndex < totalSamples; sampleIndex++) {
        // Use Halton sequence for temporal anti-aliasing (better coverage than random)
        vec2 taaOffset = taaJitter(frameIndex, sampleIndex);
        
        // Combine TAA jitter with additional random jitter for intra-pixel sampling
        vec2 randomJitter = (rand2(vec2(pixelCoord) + vec2(sampleIndex, frameIndex)) - 0.5) * 0.5;
        vec2 jitter = (taaOffset + randomJitter) / u_Resolution;
        
        vec2 uv = ((vec2(pixelCoord) + 0.5 + jitter * u_Resolution) / u_Resolution) * 2.0 - 1.0;
        uv.y = -uv.y; // Flip Y for Vulkan coordinate system (origin at top-left)
        uv.x *= u_Resolution.x / u_Resolution.y; // Aspect ratio correction
        
        vec3 rayDir = normalize(
            u_CameraForward + 
            uv.x * tanHalfFov * u_CameraRight + 
            uv.y * tanHalfFov * u_CameraUp
        );

        vec3 sampleColor = vec3(0.0);
        vec3 throughput = vec3(1.0);
        vec3 origin = u_CameraPos;
        vec3 dir = rayDir;

        for (int bounce = 0; bounce < maxBounces; bounce++) {
            vec3 hitColor;
            vec3 hitPos;
            vec3 hitNormal;
            bool hitDisk = traceOnce(origin, dir, hitColor, hitPos, hitNormal);

            sampleColor += throughput * hitColor;

            if (!hitDisk) {
                break;
            }

            // Better bounce attenuation based on surface roughness approximation
            throughput *= 0.5;
            origin = hitPos + hitNormal * 0.02;
            
            // Add slight randomization to reflection for softer bounces
            vec3 randomDir = normalize(vec3(
                hash(vec2(pixelCoord) + vec2(bounce, sampleIndex)) - 0.5,
                hash(vec2(pixelCoord) + vec2(bounce + 1, sampleIndex)) - 0.5,
                hash(vec2(pixelCoord) + vec2(bounce + 2, sampleIndex)) - 0.5
            ));
            vec3 reflectDir = reflect(dir, hitNormal);
            dir = normalize(mix(reflectDir, randomDir, 0.1)); // Slightly rough reflection
        }

        // NaN protection for sample
        if (!any(isnan(sampleColor)) && !any(isinf(sampleColor))) {
            color += sampleColor;
        }
    }

    color /= float(totalSamples);
    
    // Clamp color before accumulation to prevent extreme values
    color = clamp(color, vec3(0.0), vec3(100.0));

    vec4 accum = resetAccum ? vec4(0.0) : imageLoad(accumImage, pixelCoord);
    if (accumulateEnabled) {
        accum.rgb += color;
        accum.a += 1.0;
    } else {
        accum = vec4(color, 1.0);
    }
    imageStore(accumImage, pixelCoord, accum);

    vec3 finalColor = accum.rgb / max(accum.a, 1.0);

    if (denoiseEnabled) {
        vec3 sum = finalColor;
        float totalWeight = 1.0;
        
        // Edge-aware bilateral filter for better denoising
        for (int oy = -1; oy <= 1; oy++) {
            for (int ox = -1; ox <= 1; ox++) {
                if (ox == 0 && oy == 0) continue;
                ivec2 np = pixelCoord + ivec2(ox, oy);
                if (np.x < 0 || np.y < 0 || np.x >= resolution.x || np.y >= resolution.y) continue;
                vec4 nacc = imageLoad(accumImage, np);
                vec3 ncol = nacc.rgb / max(nacc.a, 1.0);
                
                // Edge-aware weight based on color similarity
                float colorDiff = length(ncol - finalColor);
                float weight = exp(-colorDiff * colorDiff * 10.0);
                
                sum += ncol * weight;
                totalWeight += weight;
            }
        }
        finalColor = sum / totalWeight;
    }
    
    // ============================================
    // Bloom extraction and application
    // ============================================
    
    // Extract bright areas for bloom
    float brightness = dot(finalColor, vec3(0.2126, 0.7152, 0.0722));
    float bloomThreshold = 1.2;
    float bloomIntensity = 0.15;
    
    vec3 bloomColor = vec3(0.0);
    if (brightness > bloomThreshold) {
        // Sample neighboring pixels for bloom spread (simple 5x5 gaussian-like)
        float bloomWeight = 0.0;
        for (int by = -2; by <= 2; by++) {
            for (int bx = -2; bx <= 2; bx++) {
                ivec2 bp = pixelCoord + ivec2(bx, by);
                if (bp.x < 0 || bp.y < 0 || bp.x >= resolution.x || bp.y >= resolution.y) continue;
                vec4 bacc = imageLoad(accumImage, bp);
                vec3 bcol = bacc.rgb / max(bacc.a, 1.0);
                float bBright = dot(bcol, vec3(0.2126, 0.7152, 0.0722));
                if (bBright > bloomThreshold) {
                    float dist = length(vec2(bx, by));
                    float w = exp(-dist * dist * 0.3);
                    bloomColor += bcol * (bBright - bloomThreshold) * w;
                    bloomWeight += w;
                }
            }
        }
        if (bloomWeight > 0.0) {
            bloomColor /= bloomWeight;
        }
    }
    
    // Add bloom
    finalColor += bloomColor * bloomIntensity;
    
    // ============================================
    // ACES Filmic Tone Mapping
    // ============================================
    // Based on the ACES filmic tone mapping curve
    // Attempt to match the Academy Color Encoding System
    
    // Apply exposure adjustment
    float exposure = 1.0;
    finalColor *= exposure;
    
    // ACES input transform (sRGB to ACES)
    mat3 aces_input_matrix = mat3(
        0.59719, 0.07600, 0.02840,
        0.35458, 0.90834, 0.13383,
        0.04823, 0.01566, 0.83777
    );
    
    // ACES output transform (ACES to sRGB)
    mat3 aces_output_matrix = mat3(
         1.60475, -0.10208, -0.00327,
        -0.53108,  1.10813, -0.07276,
        -0.07367, -0.00605,  1.07602
    );
    
    // Apply RRT and ODT fit
    vec3 v = aces_input_matrix * finalColor;
    vec3 a = v * (v + 0.0245786) - 0.000090537;
    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
    finalColor = aces_output_matrix * (a / max(b, vec3(EPSILON)));
    
    // NaN/Inf protection - replace invalid values with black
    if (any(isnan(finalColor)) || any(isinf(finalColor))) {
        finalColor = vec3(0.0);
    }
    
    // Clamp to valid range
    finalColor = clamp(finalColor, 0.0, 1.0);
    
    // ============================================
    // Additional post-processing
    // ============================================
    
    // Subtle vignette for cinematic look
    vec2 uv = vec2(pixelCoord) / u_Resolution;
    float vignette = 1.0 - dot(uv - 0.5, uv - 0.5) * 0.5;
    vignette = smoothstep(0.2, 1.0, vignette);
    finalColor *= mix(0.85, 1.0, vignette);
    
    // Film grain disabled - was causing visible noise on dark surfaces
    // float grain = hash(vec2(pixelCoord) + u_Time) * 0.02;
    // finalColor += vec3(grain - 0.01);
    
    // Gamma correction (sRGB)
    finalColor = pow(max(finalColor, vec3(0.0)), vec3(0.4545));
    
    imageStore(outputImage, pixelCoord, vec4(finalColor, 1.0));
}
