#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(set = 0, binding = 0, rgba32f) uniform image2D outputImage;
layout(set = 0, binding = 4, rgba32f) uniform image2D accumImage;

layout(set = 0, binding = 1) uniform UniformBlock {
    vec2 u_Resolution;
    float u_Time;
    float _pad1;
    vec3 u_CameraPos;
    float _pad2;
    vec3 u_CameraForward;
    float _pad3;
    vec3 u_CameraRight;
    float _pad4;
    vec3 u_CameraUp;
    float u_Fov;
    vec3 u_BlackHolePos;
    float u_BlackHoleMass;
    float u_SchwarzschildRadius;
    float u_DiskInnerRadius;
    float u_DiskOuterRadius;
    vec4 u_RaySettings;
    vec4 u_FrameSettings;
    vec4 u_LensingSettings;  // x=maxSteps, y=stepSize, z=bvhCheckInterval, w=quality(0-2)
    // Kerr black hole parameters (rotating black holes)
    float u_BlackHoleSpin;       // Dimensionless spin parameter a* (0 to 0.998)
    float u_KerrParameter;       // a = a* * M (spin in geometric units)
    float u_OuterHorizonRadius;  // r+ = M + sqrt(M^2 - a^2)
    float u_ErgosphereRadius;    // Equatorial ergosphere radius
    vec3 u_BlackHoleSpinAxis;    // Spin axis direction (normalized)
    float _padKerr;
};

struct BvhNode {
    vec3 boundsMin;
    int leftFirst;
    vec3 boundsMax;
    int triCount;
};

struct GpuTriangle {
    vec3 v0;
    int materialIndex;
    vec3 v1;
    int pad1;
    vec3 v2;
    int pad2;
    vec3 normal;
    int pad3;
    vec4 albedo;
    vec4 emissive;
};

layout(std430, set = 0, binding = 2) buffer BvhNodes {
    BvhNode bvhNodes[];
};

layout(std430, set = 0, binding = 3) buffer Triangles {
    GpuTriangle triangles[];
};

// Constants
const float PI = 3.14159265359;

// Lensing quality settings from uniforms (with fallback defaults)
int getMaxSteps() { return u_LensingSettings.x > 0.0 ? int(u_LensingSettings.x) : 64; }
float getStepSize() { return u_LensingSettings.y > 0.0 ? u_LensingSettings.y : 0.4; }
int getBvhCheckInterval() { return u_LensingSettings.z > 0.0 ? int(u_LensingSettings.z) : 6; }

// ============================================
// Schwarzschild Geodesic Integration
// ============================================

// Calculate gravitational acceleration for light ray bending
// Using the geodesic equation for Schwarzschild metric
vec3 schwarzschildAcceleration(vec3 pos, vec3 vel, float rs) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    
    if (rMag < rs * 0.5) {
        return vec3(0.0); // Inside event horizon
    }
    
    // Angular momentum (cross product of position and velocity)
    vec3 h = cross(r, vel);
    float h2 = dot(h, h);
    
    // Schwarzschild geodesic acceleration
    // d²r/dλ² = -1.5 * rs * h² / r⁵ * r_hat
    float r5 = rMag * rMag * rMag * rMag * rMag;
    vec3 accel = -1.5 * rs * h2 / r5 * r;
    
    return accel;
}

// ============================================
// Kerr (Rotating) Black Hole Geodesic
// ============================================

// Calculate frame dragging angular velocity (omega) for Kerr metric
// omega = 2Mar / ((r^2 + a^2)^2 - a^2 * Delta * sin^2(theta))
// where Delta = r^2 - 2Mr + a^2
float frameDraggingOmega(float r, float theta, float M, float a) {
    if (r < M * 0.5) return 0.0; // Inside singularity region
    
    float r2 = r * r;
    float a2 = a * a;
    float Delta = r2 - 2.0 * M * r + a2;
    float sinTheta = sin(theta);
    float sin2Theta = sinTheta * sinTheta;
    
    // Sigma = r^2 + a^2 * cos^2(theta)
    float cosTheta = cos(theta);
    float Sigma = r2 + a2 * cosTheta * cosTheta;
    
    // Denominator: (r^2 + a^2)^2 - a^2 * Delta * sin^2(theta)
    float rpa2 = r2 + a2;
    float denom = rpa2 * rpa2 - a2 * Delta * sin2Theta;
    
    if (abs(denom) < 1e-10) return 0.0;
    
    return 2.0 * M * a * r / denom;
}

// Calculate gravitational acceleration for Kerr metric with frame dragging
// This combines the Schwarzschild-like radial attraction with azimuthal frame dragging
vec3 kerrAcceleration(vec3 pos, vec3 vel, float rs, float a, vec3 spinAxis) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    float M = rs * 0.5; // Mass in geometric units (rs = 2M)
    
    // Use outer horizon radius if available, else compute from rs and a
    float rPlus = u_OuterHorizonRadius > 0.0 ? u_OuterHorizonRadius : (M + sqrt(max(M*M - a*a, 0.0)));
    
    if (rMag < rPlus * 0.5) {
        return vec3(0.0); // Inside event horizon
    }
    
    // Start with Schwarzschild-like acceleration
    vec3 h = cross(r, vel);
    float h2 = dot(h, h);
    float r5 = rMag * rMag * rMag * rMag * rMag;
    vec3 accelRadial = -1.5 * rs * h2 / r5 * r;
    
    // If no spin, return pure Schwarzschild
    if (abs(a) < 1e-10) {
        return accelRadial;
    }
    
    // Calculate theta (angle from spin axis)
    vec3 rNorm = r / rMag;
    float cosTheta = dot(rNorm, spinAxis);
    float theta = acos(clamp(cosTheta, -1.0, 1.0));
    
    // Frame dragging angular velocity
    float omega = frameDraggingOmega(rMag, theta, M, a);
    
    // Frame dragging velocity: v_drag = omega * (spinAxis x r)
    // This is the velocity that local inertial frames are dragged with
    vec3 dragDirection = cross(spinAxis, rNorm);
    float dragDirLen = length(dragDirection);
    
    if (dragDirLen > 1e-6) {
        dragDirection /= dragDirLen;
        
        // The frame dragging "pulls" the light ray azimuthally
        // Acceleration toward the dragging direction
        float dragStrength = omega * rMag * sin(theta);
        
        // Scale by distance factor (stronger closer to black hole)
        float distFactor = rs / (rMag * rMag);
        distFactor = min(distFactor, 1.0);
        
        vec3 accelDrag = dragDirection * dragStrength * distFactor;
        
        return accelRadial + accelDrag;
    }
    
    return accelRadial;
}

// Check if position is inside the ergosphere
// Ergosphere radius: r_ergo = M + sqrt(M^2 - a^2 * cos^2(theta))
bool isInsideErgosphere(vec3 pos, float M, float a, vec3 spinAxis) {
    vec3 r = pos - u_BlackHolePos;
    float rMag = length(r);
    
    vec3 rNorm = r / rMag;
    float cosTheta = dot(rNorm, spinAxis);
    float cos2Theta = cosTheta * cosTheta;
    
    float ergoRadius = M + sqrt(max(M*M - a*a * cos2Theta, 0.0));
    return rMag < ergoRadius;
}

// ============================================
// Accretion Disk
// ============================================

// Temperature-based color for accretion disk (simplified blackbody)
vec3 diskColor(vec3 hitPos, float rs) {
    float distFromCenter = length(hitPos.xz - u_BlackHolePos.xz);
    
    // Temperature decreases with distance from center
    float t = (distFromCenter - u_DiskInnerRadius) / (u_DiskOuterRadius - u_DiskInnerRadius);
    t = clamp(t, 0.0, 1.0);
    
    // Inner disk is hotter (bluer/whiter), outer is cooler (redder)
    vec3 hotColor = vec3(1.0, 0.9, 0.8);   // White-hot
    vec3 warmColor = vec3(1.0, 0.6, 0.2);  // Orange
    vec3 coolColor = vec3(0.8, 0.2, 0.1);  // Red
    
    vec3 color;
    if (t < 0.5) {
        color = mix(hotColor, warmColor, t * 2.0);
    } else {
        color = mix(warmColor, coolColor, (t - 0.5) * 2.0);
    }
    
    // Add some turbulence/variation
    float angle = atan(hitPos.z - u_BlackHolePos.z, hitPos.x - u_BlackHolePos.x);
    float turbulence = sin(angle * 10.0 + u_Time * 2.0) * 0.1 + 0.9;
    
    // Brightness based on distance (closer = brighter due to gravitational heating)
    float brightness = 1.0 / (1.0 + t * 2.0);
    
    return color * brightness * turbulence * 2.0;
}

// ============================================
// Procedural Starfield
// ============================================

// Simple hash function for procedural generation
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

vec2 rand2(vec2 p) {
    return vec2(
        hash(p + vec2(11.3, 17.7)),
        hash(p + vec2(31.7, 47.9))
    );
}

bool intersectAabb(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax, out float tmin, out float tmax) {
    vec3 inv = 1.0 / rd;
    vec3 t0 = (bmin - ro) * inv;
    vec3 t1 = (bmax - ro) * inv;
    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);
    tmin = max(max(tmin3.x, tmin3.y), max(tmin3.z, 0.0));
    tmax = min(min(tmax3.x, tmax3.y), tmax3.z);
    return tmax >= tmin;
}

bool intersectTriangle(vec3 ro, vec3 rd, GpuTriangle tri, out float t) {
    vec3 v0v1 = tri.v1 - tri.v0;
    vec3 v0v2 = tri.v2 - tri.v0;
    vec3 pvec = cross(rd, v0v2);
    float det = dot(v0v1, pvec);
    if (abs(det) < 1e-6) return false;
    float invDet = 1.0 / det;
    vec3 tvec = ro - tri.v0;
    float u = dot(tvec, pvec) * invDet;
    if (u < 0.0 || u > 1.0) return false;
    vec3 qvec = cross(tvec, v0v1);
    float v = dot(rd, qvec) * invDet;
    if (v < 0.0 || u + v > 1.0) return false;
    t = dot(v0v2, qvec) * invDet;
    return t > 0.0001;
}

bool intersectBvh(vec3 ro, vec3 rd, int nodeCount, int triCount, out vec3 hitPos, out vec3 hitNormal, out vec3 hitColor) {
    if (nodeCount == 0 || triCount == 0) return false;

    float tClosest = 1e20;
    bool hit = false;

    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        int nodeIndex = stack[--stackPtr];
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;
        BvhNode node = bvhNodes[nodeIndex];

        float tmin;
        float tmax;
        if (!intersectAabb(ro, rd, node.boundsMin, node.boundsMax, tmin, tmax) || tmin > tClosest) {
            continue;
        }

        if (node.triCount > 0) {
            int first = node.leftFirst;
            for (int i = 0; i < node.triCount; i++) {
                int triIndex = first + i;
                if (triIndex < 0 || triIndex >= triCount) continue;
                GpuTriangle tri = triangles[triIndex];
                float t;
                if (intersectTriangle(ro, rd, tri, t) && t < tClosest) {
                    tClosest = t;
                    hit = true;
                    hitNormal = tri.normal;
                    hitColor = tri.albedo.rgb + tri.emissive.rgb;
                }
            }
        } else {
            int left = node.leftFirst;
            int right = left + 1;
            if (right < nodeCount && stackPtr < 63) stack[stackPtr++] = right;
            if (left < nodeCount && stackPtr < 63) stack[stackPtr++] = left;
        }
    }

    if (hit) {
        hitPos = ro + rd * tClosest;
    }
    return hit;
}

// Procedural starfield on unit sphere
vec3 starfield(vec3 dir) {
    // Normalize direction
    dir = normalize(dir);
    
    // Convert direction to spherical coordinates
    float phi = atan(dir.z, dir.x);
    float theta = asin(clamp(dir.y, -1.0, 1.0));
    
    // Create a grid on the sphere
    vec2 grid = vec2(phi, theta) * 50.0;
    vec2 gridId = floor(grid);
    vec2 gridUv = fract(grid);
    
    // Random star position within cell
    vec2 starPos = vec2(hash(gridId), hash(gridId + 100.0));
    float starDist = length(gridUv - starPos);
    
    // Star brightness based on random value
    float starBrightness = hash(gridId + 200.0);
    
    // Background - dark space
    vec3 bgColor = vec3(0.0, 0.0, 0.02);
    
    // Stars - more of them and brighter
    if (starBrightness > 0.92) {
        float star = smoothstep(0.08, 0.0, starDist);
        
        // Star color variation
        vec3 starColor = vec3(1.0);
        float colorRand = hash(gridId + 300.0);
        if (colorRand < 0.3) {
            starColor = vec3(1.0, 0.9, 0.7); // Warm yellow
        } else if (colorRand < 0.6) {
            starColor = vec3(0.7, 0.8, 1.0); // Cool blue
        }
        
        float intensity = (starBrightness - 0.92) * 12.0;
        return bgColor + starColor * star * intensity;
    }
    
    return bgColor;
}

// ============================================
// Main Raytracing
// ============================================

// Simple ray-sphere intersection for the event horizon visualization
float intersectSphere(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b * b - c;
    if (h < 0.0) return -1.0;
    return -b - sqrt(h);
}

// Check BVH intersection for a short ray segment (used during geodesic tracing)
bool intersectBvhSegment(vec3 ro, vec3 rd, float maxDist, int nodeCount, int triCount, 
                          out float hitT, out vec3 hitNormal, out vec3 hitColor) {
    if (nodeCount == 0 || triCount == 0) return false;

    float tClosest = maxDist;
    bool hit = false;

    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        int nodeIndex = stack[--stackPtr];
        if (nodeIndex < 0 || nodeIndex >= nodeCount) continue;
        BvhNode node = bvhNodes[nodeIndex];

        float tmin, tmax;
        if (!intersectAabb(ro, rd, node.boundsMin, node.boundsMax, tmin, tmax) || tmin > tClosest) {
            continue;
        }

        if (node.triCount > 0) {
            int first = node.leftFirst;
            for (int i = 0; i < node.triCount; i++) {
                int triIndex = first + i;
                if (triIndex < 0 || triIndex >= triCount) continue;
                GpuTriangle tri = triangles[triIndex];
                float t;
                if (intersectTriangle(ro, rd, tri, t) && t < tClosest && t > 0.001) {
                    tClosest = t;
                    hit = true;
                    hitNormal = tri.normal;
                    hitColor = tri.albedo.rgb + tri.emissive.rgb;
                }
            }
        } else {
            int left = node.leftFirst;
            int right = left + 1;
            if (right < nodeCount && stackPtr < 63) stack[stackPtr++] = right;
            if (left < nodeCount && stackPtr < 63) stack[stackPtr++] = left;
        }
    }

    if (hit) {
        hitT = tClosest;
    }
    return hit;
}

bool traceOnce(vec3 rayOrigin, vec3 rayDir, out vec3 outColor, out vec3 hitPos, out vec3 hitNormal) {
    int nodeCount = int(u_RaySettings.z + 0.5);
    int triCount = int(u_RaySettings.w + 0.5);
    
    float rs = u_SchwarzschildRadius;
    
    // Kerr black hole parameters
    float a = u_KerrParameter;                    // Kerr parameter (spin in geometric units)
    float spin = u_BlackHoleSpin;                 // Dimensionless spin (0 to ~1)
    vec3 spinAxis = normalize(u_BlackHoleSpinAxis);
    float eventHorizon = u_OuterHorizonRadius > 0.0 ? u_OuterHorizonRadius : rs;
    bool useKerr = abs(spin) > 0.001;             // Use Kerr geodesics if spinning
    
    // If no black hole (rs <= 0), use simple straight-line BVH intersection
    if (rs <= 0.0) {
        vec3 hitColor;
        if (intersectBvh(rayOrigin, rayDir, nodeCount, triCount, hitPos, hitNormal, hitColor)) {
            outColor = hitColor;
            return true;
        }
        outColor = starfield(rayDir);
        hitPos = rayOrigin + rayDir * 100.0;
        hitNormal = vec3(0.0, 1.0, 0.0);
        return false;
    }

    // Quick distance check - if ray starts far from black hole and points away, use simple trace
    vec3 toBH = u_BlackHolePos - rayOrigin;
    float distToBH = length(toBH);
    float dotDir = dot(normalize(toBH), rayDir);
    
    // If far from black hole and not pointing toward it, skip geodesic tracing
    if (distToBH > rs * 20.0 && dotDir < 0.3) {
        vec3 hitColor;
        if (intersectBvh(rayOrigin, rayDir, nodeCount, triCount, hitPos, hitNormal, hitColor)) {
            outColor = hitColor;
            return true;
        }
        outColor = starfield(rayDir);
        hitPos = rayOrigin + rayDir * 100.0;
        hitNormal = vec3(0.0, 1.0, 0.0);
        return false;
    }

    // Get quality settings from uniforms
    int maxSteps = getMaxSteps();
    float baseStepSize = getStepSize();
    int bvhInterval = getBvhCheckInterval();
    
    // Trace ray along curved geodesic path
    vec3 pos = rayOrigin;
    vec3 vel = normalize(rayDir);
    float totalDist = 0.0;
    
    for (int i = 0; i < maxSteps; i++) {
        // Distance from current position to black hole center
        vec3 relPos = pos - u_BlackHolePos;
        float dist = length(relPos);
        
        // Adaptive step size - larger when far from black hole
        float step = baseStepSize * clamp(dist / (rs * 2.0), 0.1, 2.0);
        
        // Check if fallen into event horizon (use outer horizon for Kerr)
        if (dist < eventHorizon) {
            outColor = vec3(0.0); // Black - absorbed by black hole
            hitPos = pos;
            hitNormal = vec3(0.0, 1.0, 0.0);
            return false;
        }
        
        // Only check BVH periodically to save performance (every N steps or when far from BH)
        bool checkBvh = (i % bvhInterval == 0) || (dist > rs * 8.0);
        
        if (checkBvh) {
            float hitT;
            vec3 segHitNormal, segHitColor;
            float checkDist = step * float(bvhInterval) * 1.2;
            if (intersectBvhSegment(pos, vel, checkDist, nodeCount, triCount, hitT, segHitNormal, segHitColor)) {
                hitPos = pos + vel * hitT;
                hitNormal = segHitNormal;
                outColor = segHitColor;
                return true;
            }
        }
        
        // Store old position for disk intersection test
        vec3 oldPos = pos;
        
        // Calculate acceleration based on black hole type
        vec3 accel;
        if (useKerr) {
            // Use Kerr geodesic with frame dragging
            accel = kerrAcceleration(pos, vel, rs, a, spinAxis);
        } else {
            // Use simpler Schwarzschild approximation
            vec3 towardMass = -normalize(relPos);
            float bendStrength = rs * 1.5 / (dist * dist);
            bendStrength = min(bendStrength, 0.5);
            accel = towardMass * bendStrength;
        }
        
        vel += accel * step;
        vel = normalize(vel);
        pos = pos + vel * step;
        totalDist += step;
        
        // Check for accretion disk intersection
        // For Kerr black holes, disk is perpendicular to spin axis
        // For Schwarzschild, use Y-axis (spinAxis defaults to (0,1,0))
        vec3 diskNormal = useKerr ? spinAxis : vec3(0.0, 1.0, 0.0);
        
        // Signed distance from disk plane (plane passes through black hole center)
        float d1 = dot(oldPos - u_BlackHolePos, diskNormal);
        float d2 = dot(pos - u_BlackHolePos, diskNormal);
        
        if (d1 * d2 < 0.0) {
            // Ray crossed the disk plane
            float t = abs(d1) / (abs(d1) + abs(d2));
            vec3 diskHitPos = mix(oldPos, pos, t);
            
            // Distance from center in the disk plane
            vec3 toDiskHit = diskHitPos - u_BlackHolePos;
            vec3 inPlane = toDiskHit - dot(toDiskHit, diskNormal) * diskNormal;
            float distFromCenter = length(inPlane);
            
            if (distFromCenter >= u_DiskInnerRadius && distFromCenter <= u_DiskOuterRadius) {
                outColor = diskColor(diskHitPos, rs);
                hitPos = diskHitPos;
                hitNormal = dot(vel, diskNormal) > 0.0 ? -diskNormal : diskNormal;
                return true;
            }
        }
        
        // Check if ray escaped (far from black hole or traveled far enough)
        if (dist > rs * 25.0 || totalDist > 100.0) {
            // Do one final BVH check before returning starfield
            float hitT;
            vec3 segHitNormal, segHitColor;
            if (intersectBvhSegment(pos, vel, 50.0, nodeCount, triCount, hitT, segHitNormal, segHitColor)) {
                hitPos = pos + vel * hitT;
                hitNormal = segHitNormal;
                outColor = segHitColor;
                return true;
            }
            outColor = starfield(vel);
            hitPos = pos;
            hitNormal = vec3(0.0, 1.0, 0.0);
            return false;
        }
    }
    
    // Max iterations reached - return starfield based on final direction
    outColor = starfield(vel);
    hitPos = pos;
    hitNormal = vec3(0.0, 1.0, 0.0);
    return false;
}

void main() {
    uvec3 gid = gl_GlobalInvocationID;
    ivec2 pixelCoord = ivec2(gid.xy);
    ivec2 resolution = ivec2(u_Resolution);
    
    // Bounds check
    if (pixelCoord.x >= resolution.x || pixelCoord.y >= resolution.y) {
        return;
    }
    
    int raysPerPixel = clamp(int(u_RaySettings.x + 0.5), 1, 64);
    int maxBounces = clamp(int(u_RaySettings.y + 0.5), 1, 8);
    int samplesPerFrame = clamp(int(u_FrameSettings.x + 0.5), 1, 8);
    int frameIndex = int(u_FrameSettings.y + 0.5);
    bool accumulateEnabled = u_FrameSettings.z > 0.5;
    bool denoiseEnabled = u_FrameSettings.w > 0.5;
    bool resetAccum = !accumulateEnabled || frameIndex == 0;

    vec3 color = vec3(0.0);
    
    // Calculate ray direction based on camera and FOV
    float fovRad = u_Fov * PI / 180.0;
    float tanHalfFov = tan(fovRad * 0.5);

    int totalSamples = raysPerPixel * samplesPerFrame;
    for (int sampleIndex = 0; sampleIndex < totalSamples; sampleIndex++) {
        vec2 jitter = (rand2(vec2(pixelCoord) + vec2(sampleIndex + frameIndex * 13, u_Time * 10.0)) - 0.5) / u_Resolution;
        vec2 uv = ((vec2(pixelCoord) + jitter) / u_Resolution) * 2.0 - 1.0;
        uv.y = -uv.y; // Flip Y for Vulkan coordinate system (origin at top-left)
        uv.x *= u_Resolution.x / u_Resolution.y; // Aspect ratio correction
        
        vec3 rayDir = normalize(
            u_CameraForward + 
            uv.x * tanHalfFov * u_CameraRight + 
            uv.y * tanHalfFov * u_CameraUp
        );

        vec3 sampleColor = vec3(0.0);
        vec3 throughput = vec3(1.0);
        vec3 origin = u_CameraPos;
        vec3 dir = rayDir;

        for (int bounce = 0; bounce < maxBounces; bounce++) {
            vec3 hitColor;
            vec3 hitPos;
            vec3 hitNormal;
            bool hitDisk = traceOnce(origin, dir, hitColor, hitPos, hitNormal);

            sampleColor += throughput * hitColor;

            if (!hitDisk) {
                break;
            }

            throughput *= 0.6;
            origin = hitPos + hitNormal * 0.02;
            dir = reflect(dir, hitNormal);
        }

        color += sampleColor;
    }

    color /= float(totalSamples);

    vec4 accum = resetAccum ? vec4(0.0) : imageLoad(accumImage, pixelCoord);
    if (accumulateEnabled) {
        accum.rgb += color;
        accum.a += 1.0;
    } else {
        accum = vec4(color, 1.0);
    }
    imageStore(accumImage, pixelCoord, accum);

    vec3 finalColor = accum.rgb / max(accum.a, 1.0);

    if (denoiseEnabled) {
        vec3 sum = finalColor;
        int count = 1;
        for (int oy = -1; oy <= 1; oy++) {
            for (int ox = -1; ox <= 1; ox++) {
                if (ox == 0 && oy == 0) continue;
                ivec2 np = pixelCoord + ivec2(ox, oy);
                if (np.x < 0 || np.y < 0 || np.x >= resolution.x || np.y >= resolution.y) continue;
                vec4 nacc = imageLoad(accumImage, np);
                vec3 ncol = nacc.rgb / max(nacc.a, 1.0);
                sum += ncol;
                count++;
            }
        }
        finalColor = sum / float(count);
    }
    
    // Simple tone mapping
    finalColor = finalColor / (finalColor + vec3(1.0));
    
    // Gamma correction
    finalColor = pow(finalColor, vec3(0.4545)); // 1.0/2.2 = 0.4545
    
    imageStore(outputImage, pixelCoord, vec4(finalColor, 1.0));
}
